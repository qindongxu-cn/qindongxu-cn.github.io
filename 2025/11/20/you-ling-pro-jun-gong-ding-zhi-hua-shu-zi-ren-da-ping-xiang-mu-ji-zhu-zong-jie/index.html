<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="有灵Pro：军工定制化数字人大屏项目技术总结, UESTC CV DeepLearning MachineLearning 秦东旭 sunhw Hongwei 计算机视觉 深度学习"><meta name="baidu-site-verification" content="fmlEuI34ir"><meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY"><meta name="description" content="有灵 Pro：军工定制化数字人大屏项目技术总结项目概述有灵 Pro 是一款面向军工领域定制化的数字人大屏应用，基于 Electron + Vue 3 + TypeScript 构建。项目集成了数字人渲染、挥手唤醒、语音识别、人脸识别、3D "><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="preconnect" href="https://busuanzi.ibruce.info" crossorigin><link rel="dns-prefetch" href="//sdk.jinrishici.com"><link rel="preconnect" href="https://sdk.jinrishici.com" crossorigin><title>有灵Pro：军工定制化数字人大屏项目技术总结 | 秦东旭的博客</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/aos/3.0.0-beta.6/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script defer src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>window.addEventListener("load",function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.defer=!0,document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)})</script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">秦东旭的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/AV" class="waves-effect waves-light"><i class="fa fa-music"></i> <span>视听</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/galleries" class="waves-effect waves-light"><i class="fa fa-photo"></i> <span>相册</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于我</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">秦东旭的博客</div><div class="logo-desc">上海市前端开发工程师</div></div><ul class="menu-list mobile-menu-list"><li><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li><a href="/AV" class="waves-effect waves-light"><i class="fa fa-fw fa-music"></i> 视听</a></li><li><a href="/galleries" class="waves-effect waves-light"><i class="fa fa-fw fa-photo"></i> 相册</a></li><li><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于我</a></li><li><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言板</a></li><li><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/qindongxu-cn/qindongxu-cn.github.io" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/qindongxu-cn/qindongxu-cn.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/8.jpg)"><div class="container"><div class="row"><div class="col s12 m12 l12"><div class="brand"><div class="description center-align post-title">有灵Pro：军工定制化数字人大屏项目技术总结</div></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}#floating-toc-btn{position:fixed;right:20px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Vue3/" target="_blank"><span class="chip bg-color">Vue3</span> </a><a href="/tags/Electron/" target="_blank"><span class="chip bg-color">Electron</span> </a><a href="/tags/Three-js/" target="_blank"><span class="chip bg-color">Three.js</span> </a><a href="/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/" target="_blank"><span class="chip bg-color">数字人</span> </a><a href="/tags/%E5%86%9B%E5%B7%A5%E9%A1%B9%E7%9B%AE/" target="_blank"><span class="chip bg-color">军工项目</span> </a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank"><span class="chip bg-color">技术总结</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-category" target="_blank">项目总结</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2025-11-20</div><div class="post-author info-break-policy"><i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp; 秦东旭</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 14.6k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 61 分</div><span id="busuanzi_container_site_pv" style="display:none"></span> <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="有灵-Pro：军工定制化数字人大屏项目技术总结"><a href="#有灵-Pro：军工定制化数字人大屏项目技术总结" class="headerlink" title="有灵 Pro：军工定制化数字人大屏项目技术总结"></a>有灵 Pro：军工定制化数字人大屏项目技术总结</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p><strong>有灵 Pro</strong> 是一款面向军工领域定制化的数字人大屏应用，基于 Electron + Vue 3 + TypeScript 构建。项目集成了数字人渲染、挥手唤醒、语音识别、人脸识别、3D 模型展示等多项核心技术，实现了智能化、多模态的人机交互体验。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li><strong>前端框架</strong>: Vue 3 + TypeScript + Vite</li><li><strong>桌面应用</strong>: Electron 36.4.0</li><li><strong>状态管理</strong>: Pinia + RxJS（响应式编程）</li><li><strong>3D 渲染</strong>: Three.js 0.181.2</li><li><strong>数字人驱动</strong>: TTSA SDK</li><li><strong>构建工具</strong>: Electron-Vite</li></ul><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><p>项目采用分层架构设计，从 UI 层到基础设施层，职责清晰，便于维护和扩展：</p><pre><code>┌─────────────────────────────────────────┐
│          UI 层 (Vue Components)          │
│  - 数字人渲染器                          │
│  - 语音识别动效                          │
│  - 多模态内容展示                        │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      业务逻辑层 (Interaction Logic)       │
│  - 状态机管理 (Stage Management)        │
│  - 交互模式 (Soft/Hardware)             │
│  - 事件流处理 (RxJS)                     │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      服务层 (Services &amp; Stores)          │
│  - TTSA 数字人服务                       │
│  - ASR 语音识别服务                      │
│  - 语音唤醒服务                          │
│  - 人脸识别服务                          │
│  - 挥手唤醒服务                          │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      基础设施层 (Infrastructure)          │
│  - WebSocket 通信                        │
│  - 摄像头视频流                          │
│  - 本地服务进程                          │
└─────────────────────────────────────────┘</code></pre><hr><h2 id="一、核心功能与技术亮点"><a href="#一、核心功能与技术亮点" class="headerlink" title="一、核心功能与技术亮点"></a>一、核心功能与技术亮点</h2><h3 id="1-1-数字人渲染与实时驱动"><a href="#1-1-数字人渲染与实时驱动" class="headerlink" title="1.1 数字人渲染与实时驱动"></a>1.1 数字人渲染与实时驱动</h3><h4 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h4><p>项目通过 TTSA SDK 实现数字人的实时渲染和驱动，核心逻辑位于 <code>src/stores/store-ttsa/</code>。</p><p><strong>关键特性</strong>：</p><ul><li><strong>流式对话驱动</strong>：支持流式文本驱动的数字人发言</li><li><strong>状态管理</strong>：通过 RxJS Subject 管理数字人生命周期事件</li><li><strong>视频帧回调</strong>：支持实时视频帧处理，实现背景抠除等效果</li></ul><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 数字人状态管理示例</span>
<span class="token keyword">const</span> ttsaStore <span class="token operator">=</span> <span class="token function">useTtsaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> subjects <span class="token operator">=</span> ttsaStore<span class="token punctuation">.</span>subjects<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听数字人发言结束</span>
subjects<span class="token punctuation">.</span>voice_end<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 处理发言结束逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数字人渲染架构"><a href="#数字人渲染架构" class="headerlink" title="数字人渲染架构"></a>数字人渲染架构</h4><p>数字人渲染采用 <strong>WebGL + OGL</strong> 技术栈，实现了高性能的实时视频流处理和颜色抠除。</p><p><strong>核心流程</strong>：</p><ol><li><strong>视频帧获取</strong>：通过 <code>requestVideoFrameCallback</code> API 获取数字人视频流的每一帧</li><li><strong>WebGL 渲染</strong>：使用 OGL 库创建 WebGL 上下文，将视频帧作为纹理渲染到 Canvas</li><li><strong>实时抠色</strong>：通过 Fragment Shader 对每一帧进行颜色抠除处理</li><li><strong>透明背景</strong>：输出带有 Alpha 通道的透明背景，支持与页面其他元素融合</li></ol><h4 id="渲染原理详解"><a href="#渲染原理详解" class="headerlink" title="渲染原理详解"></a>渲染原理详解</h4><p><strong>1. 视频帧回调机制</strong></p><p>项目使用 <code>HTMLVideoElement.requestVideoFrameCallback()</code> API 实现高性能的视频帧捕获。相比传统的 <code>requestAnimationFrame</code>，该 API 专门为视频帧同步设计，能够精确地在每一帧视频刷新时触发回调，避免不必要的渲染：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 在 useAutoSetup.ts 中实现</span>
<span class="token keyword">const</span> frameCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>frame<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 触发所有注册的视频帧回调</span>
  videoFrameCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callbacks<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span>ttsaVideo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 递归调用，形成循环</span>
  videoFrameCallbackId<span class="token punctuation">.</span>value <span class="token operator">=</span>
    ttsaVideo<span class="token punctuation">.</span><span class="token function">requestVideoFrameCallback</span><span class="token punctuation">(</span>frameCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
videoFrameCallbackId<span class="token punctuation">.</span>value <span class="token operator">=</span> ttsaVideo<span class="token punctuation">.</span><span class="token function">requestVideoFrameCallback</span><span class="token punctuation">(</span>frameCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优势</strong>：</p><ul><li><strong>帧精确同步</strong>：确保回调在视频帧刷新时触发，而不是浏览器渲染循环</li><li><strong>性能优化</strong>：自动跳过重复帧，只在视频实际更新时处理</li><li><strong>低延迟</strong>：相比 <code>requestAnimationFrame</code> 延迟更低</li></ul><p><strong>2. WebGL 渲染管线</strong></p><p>渲染器使用 <strong>OGL（轻量级 WebGL 库）</strong>构建渲染管线：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 创建渲染器（启用 Alpha 通道）</span>
<span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Renderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  canvas<span class="token punctuation">:</span> canvasRef<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
  width<span class="token punctuation">:</span> props<span class="token punctuation">.</span>width<span class="token punctuation">,</span>
  height<span class="token punctuation">:</span> props<span class="token punctuation">.</span>height<span class="token punctuation">,</span>
  alpha<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持透明背景</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 创建全屏四边形几何体</span>
<span class="token keyword">const</span> geometry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Geometry</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  a_position<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    size<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// NDC 坐标</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  a_texCoord<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    size<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 纹理坐标</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  index<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Uint16Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 索引</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 创建纹理（视频帧将作为纹理源）</span>
<span class="token keyword">const</span> texture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  generateMipmaps<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>
  minFilter<span class="token punctuation">:</span> gl<span class="token punctuation">.</span>LINEAR<span class="token punctuation">,</span>
  magFilter<span class="token punctuation">:</span> gl<span class="token punctuation">.</span>LINEAR<span class="token punctuation">,</span>
  flipY<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 翻转 Y 轴，适配视频坐标系</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 颜色抠除算法原理</strong></p><p>颜色抠除在 Fragment Shader 中实现，核心算法基于 <strong>YUV 色度空间</strong>计算颜色相似度：</p><p><strong>步骤一：RGB 转 YUV 色度空间</strong></p><p>使用色度空间而非 RGB 空间，因为色度空间对亮度变化不敏感，更适合颜色匹配：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token keyword">vec2</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> rgb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">vec2</span><span class="token punctuation">(</span>
    rgb<span class="token punctuation">.</span>r <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.169</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.331</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>b <span class="token operator">*</span>  <span class="token number">0.5</span>    <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span>
    rgb<span class="token punctuation">.</span>r <span class="token operator">*</span>  <span class="token number">0.5</span>   <span class="token operator">+</span> rgb<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.419</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>b <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.081</span>  <span class="token operator">+</span> <span class="token number">0.5</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤二：计算色度距离</strong></p><p>计算当前像素与目标颜色（绿幕）的色度向量距离：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// 计算色度向量差值</span>
<span class="token keyword">vec2</span> chromaVec <span class="token operator">=</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span>rgba<span class="token punctuation">.</span>rgb<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span>keyColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 计算色度距离（欧氏距离）</span>
<span class="token keyword">float</span> chromaDist <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>chromaVec<span class="token punctuation">,</span> chromaVec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤三：生成透明度遮罩</strong></p><p>根据色度距离和相似度阈值生成基础遮罩：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// baseMask 为负数：是绿幕（需要抠除）</span>
<span class="token comment" spellcheck="true">// baseMask 为正数：不是绿幕（保留）</span>
<span class="token keyword">float</span> baseMask <span class="token operator">=</span> chromaDist <span class="token operator">-</span> similarity<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 平滑过渡处理，生成最终的透明度</span>
<span class="token keyword">float</span> fullMask <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span>baseMask <span class="token operator">/</span> smoothness<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤四：边缘处理（Spill Suppression）</strong></p><p>绿幕边缘可能反射到前景物体上，产生绿色溢出。通过降低边缘区域的饱和度来消除：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// 计算溢出值（距离绿幕越近，溢出值越小）</span>
<span class="token keyword">float</span> spillVal <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span>baseMask <span class="token operator">/</span> spill<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 计算灰度值</span>
<span class="token keyword">float</span> desat <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>rgba<span class="token punctuation">.</span>r <span class="token operator">*</span> <span class="token number">0.2126</span> <span class="token operator">+</span> rgba<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token number">0.7152</span> <span class="token operator">+</span> rgba<span class="token punctuation">.</span>b <span class="token operator">*</span> <span class="token number">0.0722</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 根据溢出值混合原色和灰度，降低绿幕边缘的饱和度</span>
<span class="token keyword">return</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>
  <span class="token function">mix</span><span class="token punctuation">(</span><span class="token keyword">vec3</span><span class="token punctuation">(</span>desat<span class="token punctuation">,</span> desat<span class="token punctuation">,</span> desat<span class="token punctuation">)</span><span class="token punctuation">,</span> rgba<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> spillVal<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span>
  fullMask  <span class="token comment" spellcheck="true">// Alpha 通道</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完整 Shader 代码</strong>：</p><pre class="line-numbers language-1:63:apps/open-pro-client/src/core/ttsa-renderer/shaders/color-removal.fs.glsl"><code class="language-1:63:apps/open-pro-client/src/core/ttsa-renderer/shaders/color-removal.fs.glsl">#version 300 es
precision mediump float;
out vec4 FragColor;
in vec2 v_texCoord;

// 帧
uniform sampler2D frameTexture;
// 关键颜色
uniform vec3 keyColor;
// 色度的相似度计算
uniform float similarity;
// 透明度的平滑度计算
uniform float smoothness;
// 降低绿幕饱和度，提高抠图准确度
uniform float spill;
// 是否启用 0 - 禁用抠图  1 - 启用抠图
uniform float enable;

vec2 RGBtoUV(vec3 rgb) {
  return vec2(
    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,
    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5
  );
}

// 抠色逻辑
vec4 ColorRemoval(vec4 rgba) {
  // 计算当前像素与绿幕像素的色度差值
  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);

  // 计算当前像素与绿幕像素的色度距离（向量长度）, 越相像则色度距离越小
  float chromaDist = sqrt(dot(chromaVec, chromaVec));

  // 设置了一个相似度阈值, baseMask 为负，则表明是绿幕，为正则表明不是绿幕
  float baseMask = chromaDist - similarity;

  // 如果 baseMask 为负数, fullMask 等于 0; baseMask 为正数，越大，则透明度越低
  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);

  // 如果 baseMask 为负数, spillVal 等于 0; baseMask 为整数，越小，饱和度越低
  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);

  // 计算当前像素的灰度值
  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.);

  return vec4(
    mix(vec3(desat, desat, desat), rgba.rgb, spillVal).rgb,
    fullMask
  );
}

void main() {
  // 获取当前像素的 rgba 值
  vec4 rgba = texture(frameTexture, v_texCoord);

  if (enable == 0.0) {
    FragColor = rgba;
    return;
  }

  FragColor = ColorRemoval(rgba);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li><strong>similarity</strong> (0-1)：颜色相似度阈值，值越大要求越精确匹配</li><li><strong>smoothness</strong> (0-1)：透明度过渡的平滑度，值越大边缘越柔和</li><li><strong>spill</strong> (0-1)：绿幕溢出抑制强度，值越小边缘去绿效果越强</li></ul><p><strong>4. 实时渲染循环</strong></p><p>每一帧视频更新时，将视频元素作为纹理源更新到 GPU，触发 Shader 处理：</p><pre class="line-numbers language-122:127:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><code class="language-122:127:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue">  attach((video) => {
    renderer.setSize(gl.canvas.width, gl.canvas.height)
    texture.image = video
    texture.needsUpdate = true
    renderer.render({ scene: mesh })
  })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>技术亮点</strong>：</p><ul><li><strong>高性能</strong>：GPU 加速处理，支持实时 60fps 渲染</li><li><strong>低延迟</strong>：使用 <code>requestVideoFrameCallback</code> 精确同步视频帧</li><li><strong>高质量</strong>：基于 YUV 色度空间的颜色匹配算法，对亮度变化不敏感</li><li><strong>边缘优化</strong>：Spill Suppression 技术消除绿幕边缘的绿色溢出</li><li><strong>可配置</strong>：支持实时调整抠除参数，适应不同场景需求</li></ul><p><strong>完整渲染器实现</strong>：</p><pre class="line-numbers language-12:147:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><code class="language-12:147:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><script setup lang="ts">
import { Geometry, Mesh, Program, Renderer, Texture } from 'ogl'
import { useMessage } from 'xmov-ui'
import { useDevStore, useSettingStore, useTtsaStore } from '@/stores'
import colorRemovalFrag from './shaders/color-removal.fs.glsl?raw'
import colorRemovalVert from './shaders/color-removal.vs.glsl?raw'

const props = defineProps<{
  width: number
  height: number
  /** 需要被抠除的目标颜色, 颜色值为 0 ~ 255 */
  targetColor?: [R: number, G: number, B: number]
  similarity?: number
  smoothness?: number
  spill?: number
}>()

// ============================== global store ==============================
const devStore = useDevStore()
const settingStore = useSettingStore()
const ttsaStore = useTtsaStore()
const message = useMessage()

// ============================== renderder ==============================
const canvasRef = shallowRef<HTMLCanvasElement>()

/** 是否启用颜色抠除 */
const colorRemovalEnable = computed(() => {
  return Number(settingStore.settings['appearence:bg-transparent-mode'] === 'removal')
})
/** 需要被抠除的目标颜色, 颜色值为 0 ~ 255 */
const targetColor = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:target-color']
})
/** 颜色相似度 0 ~ 1, 1 表示必须精确匹配 targetColor 指定的颜色值 */
const similarity = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:similarity']
})
/** 平滑度 0 ~ 1 */
const smoothness = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:smoothness']
})
/** 饱和度 0 ~ 1 */
const spill = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:spill']
})

// ============================== draw control ==============================
const { attach, dismiss, pause, resume } = ttsaStore.useVideoFrameCallback()

onMounted(() => {
  if (!canvasRef.value) {
    message.error('渲染器容器未挂载')
    return
  }

  const renderer = new Renderer({
    canvas: canvasRef.value,
    width: props.width,
    height: props.height,
    alpha: true,
  })

  const { gl } = renderer

  const geometry = new Geometry(gl, {
    a_position: {
      size: 2,
      data: new Float32Array([-1, -1, +1, -1, +1, +1, -1, +1]),
    },
    a_texCoord: {
      size: 2,
      data: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    },
    index: {
      data: new Uint16Array([0, 1, 2, 0, 2, 3]),
    },
  })

  const texture = new Texture(gl, {
    generateMipmaps: false,
    minFilter: gl.LINEAR,
    magFilter: gl.LINEAR,
    flipY: true,
  })

  const program = new Program(gl, {
    vertex: colorRemovalVert,
    fragment: colorRemovalFrag,
    uniforms: {
      frameTexture: {
        value: texture,
      },
      keyColor: {
        value: targetColor.value,
      },
      similarity: {
        value: similarity.value,
      },
      smoothness: {
        value: smoothness.value,
      },
      spill: {
        value: spill.value,
      },
      enable: {
        value: colorRemovalEnable.value,
      },
    },
  })

  watchEffect(() => {
    program.uniforms.keyColor.value = targetColor.value
    program.uniforms.similarity.value = similarity.value
    program.uniforms.smoothness.value = smoothness.value
    program.uniforms.spill.value = spill.value
    program.uniforms.enable.value = colorRemovalEnable.value
  })

  const mesh = new Mesh(gl, { geometry, program })

  attach((video) => {
    renderer.setSize(gl.canvas.width, gl.canvas.height)
    texture.image = video
    texture.needsUpdate = true
    renderer.render({ scene: mesh })
  })
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键实现细节</strong>：</p>
<ul>
<li><strong>响应式参数更新</strong>：通过 <code>watchEffect</code> 实时更新 Shader 参数，无需重新编译</li>
<li><strong>生命周期管理</strong>：通过 <code>useVideoFrameCallback</code> 的 <code>attach</code>、<code>dismiss</code>、<code>pause</code>、<code>resume</code> 方法管理视频帧回调</li>
<li><strong>透明背景支持</strong>：启用 <code>alpha: true</code> 输出带有 Alpha 通道的透明背景</li>
</ul>
<hr>
<h3 id="1-2-挥手服务唤醒"><a href="#1-2-挥手服务唤醒" class="headerlink" title="1.2 挥手服务唤醒"></a>1.2 挥手服务唤醒</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>挥手唤醒服务采用<strong>客户端-服务器</strong>架构：</p>
<ul>
<li><strong>客户端</strong>：通过 WebSocket 实时传输摄像头视频流</li>
<li><strong>服务器</strong>：Python 后端服务，基于手势识别算法检测挥手动作</li>
<li><strong>通信协议</strong>：WebSocket 二进制数据传输</li>
</ul>
<h4 id="useCameraStream-视频流处理模块"><a href="#useCameraStream-视频流处理模块" class="headerlink" title="useCameraStream 视频流处理模块"></a>useCameraStream 视频流处理模块</h4><p><code>useCameraStream</code> 是挥手唤醒的核心模块，负责管理摄像头视频流的获取、编码、传输和统计。该模块针对不同设备和浏览器做了大量兼容性处理。</p>
<p><strong>核心功能</strong>：</p>
<ol>
<li><p><strong>摄像头设备管理</strong></p>
<ul>
<li>自动枚举所有视频输入设备</li>
<li>智能查找支持目标分辨率的摄像头</li>
<li>设备能力检测（capabilities）和约束应用（applyConstraints）</li>
<li>权限请求和错误处理</li>
</ul>
</li>
<li><p><strong>视频分辨率适配</strong></p>
<ul>
<li><strong>目标分辨率</strong>：640x480</li>
<li><strong>多策略适配</strong>：<ul>
<li>策略 1：<code>exact</code> 约束（强制要求精确分辨率）</li>
<li>策略 2：<code>min + ideal</code> 约束（最低要求 + 理想值）</li>
<li>策略 3：<code>ideal</code> 约束（仅理想值，降级方案）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>视频编码格式处理</strong></p>
<ul>
<li><strong>格式检测</strong>：支持检测 WebM、H.264、MJPEG 等格式</li>
<li><strong>格式转码</strong>：MediaRecorder 实时转码为目标格式</li>
<li><strong>优先级</strong>：vp9 &gt; vp8 &gt; h264 &gt; webm &gt; mp4</li>
</ul>
</li>
<li><p><strong>MediaRecorder 管理</strong></p>
<ul>
<li>动态创建 MediaRecorder 实例</li>
<li>支持格式切换（运行时检测和重新创建）</li>
<li>配置比特率：2.5 Mbps</li>
<li>数据块获取间隔：100ms</li>
</ul>
</li>
<li><p><strong>WebM Header 查找机制</strong></p>
<ul>
<li>累积前 5 个数据块搜索 WebM header</li>
<li>在合并缓冲区中查找 <code>1A 45 DF A3</code> 标记</li>
<li>找到后从 header 位置开始发送数据</li>
<li>超过限制后强制开始发送（防止无限等待）</li>
</ul>
</li>
<li><p><strong>实时统计</strong></p>
<ul>
<li>数据块计数</li>
<li>当前码率（Kbps）</li>
<li>总数据量（Bytes）</li>
<li>视频分辨率</li>
</ul>
</li>
</ol>
<h4 id="技术实现-1"><a href="#技术实现-1" class="headerlink" title="技术实现"></a>技术实现</h4><p><strong>1. 摄像头视频流获取</strong></p>
<p>核心代码位于 <code>src/stores/store-wave-awaken/useCameraStream.ts</code>：</p>
<pre class="line-numbers language-107:335:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-107:335:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">  /** 启动摄像头并开始录制 */
  const startCamera = async (callbacks?: CameraStreamCallbacks) => {
    try {
      // 直接使用 getUserMedia 获取摄像头视频流
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('浏览器不支持 getUserMedia API')
      }

      // 使用 ideal 而不是 exact，允许浏览器选择最接近的分辨率
      // 如果摄像头不支持 1920x1080，浏览器会自动选择最接近的支持分辨率
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 },
        },
        audio: false,
      })

      // 立即设置 mediaStream，以便预览组件可以显示
      mediaStream.value = stream

      // 获取视频轨道信息
      const videoTrack = stream.getVideoTracks()[0]
      const settings = videoTrack.getSettings()

      // 当前应用的分辨率（浏览器实际使用的分辨率）
      const appliedWidth = settings.width || 0
      const appliedHeight = settings.height || 0

      // 保存分辨率信息
      videoResolution.value = { width: appliedWidth, height: appliedHeight }

      // 检查并选择支持的视频编码格式
      const mimeType = getSupportedMimeType()
      if (!mimeType) {
        throw new Error('浏览器不支持任何视频编码格式')
      }

      // eslint-disable-next-line no-console
      console.log(`✅ 摄像头已启动: ${appliedWidth}x${appliedHeight} | 编码格式: ${mimeType}`)

      // 创建 MediaRecorder 配置
      const options: MediaRecorderOptions = {
        mimeType,
        videoBitsPerSecond: 2500000, // 2.5 Mbps
      }

      // 创建 MediaRecorder 实例
      const recorder = new MediaRecorder(stream, options)
      mediaRecorder.value = recorder

      // 初始化统计
      chunkCount.value = 0
      dataStatsStartTime.value = Date.now()
      lastChunkTime.value = null
      currentBitrate.value = 0
      totalBytesSent.value = 0
      hasFoundHeader.value = false
      headerBuffer.value = []

      // 定期更新统计信息（不打印，仅更新数据）
      statsUpdateInterval.value = window.setInterval(() => {
        if (dataStatsStartTime.value) {
          const elapsed = (Date.now() - dataStatsStartTime.value) / 1000 // 秒
          if (elapsed > 0) {
            // 计算平均比特率 (Kbps)
            const bytesPerSecond = totalBytesSent.value / elapsed
            currentBitrate.value = Math.round((bytesPerSecond * 8) / 1024) // 转换为 Kbps
          }
        }
      }, 1000) as unknown as number

      // 在缓冲区中搜索 WebM header
      // 只接受标准 WebM header: 1a 45 df a3 (0x1a45dfa3)
      // 异常 header (556f8100) 可能是编码器产生的无效数据，应该跳过并继续搜索真正的 WebM header
      const findWebMHeaderInBuffer = (buffers: Uint8Array[]): number | null => {
        // 合并所有缓冲区
        const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0)
        if (totalLength < 4) {
          return null
        }
        const merged = new Uint8Array(totalLength)
        let offset = 0
        for (const buf of buffers) {
          merged.set(buf, offset)
          offset += buf.length
        }
        // 在合并的缓冲区中搜索标准 WebM header: 1a 45 df a3
        for (let i = 0; i <= merged.length - 4; i++) {
          // 只接受标准 WebM header
          if (merged[i] === 0x1A && merged[i + 1] === 0x45 && merged[i + 2] === 0xDF && merged[i + 3] === 0xA3) {
            return i
          }
          // 如果遇到异常 header (556f8100)，跳过它继续搜索（不返回）
          // 这样可以避免将无效数据当作有效 header
        }
        return null
      }

      // 处理视频数据块
      recorder.ondataavailable = async (event) => {
        if (!event.data || event.data.size === 0) {
          return
        }

        try {
          const now = Date.now()
          const chunkSize = event.data.size

          // 将 Blob 转换为 ArrayBuffer
          const arrayBuffer = await event.data.arrayBuffer()
          const uint8Array = new Uint8Array(arrayBuffer)

          // 如果还没有找到包含 header 的数据块，累积并搜索
          if (!hasFoundHeader.value) {
            // 将当前数据块添加到缓冲区
            headerBuffer.value.push(uint8Array)

            // 如果累积的数据块数量超过限制，强制开始发送（防止无限等待）
            if (headerBuffer.value.length > MAX_HEADER_SEARCH_CHUNKS) {
              console.warn('⚠️ 已累积多个数据块但未找到 header，开始发送数据（可能 header 已被分割）')
              hasFoundHeader.value = true
            }
            else {
              // 在累积的缓冲区中搜索 header
              const headerIndex = findWebMHeaderInBuffer(headerBuffer.value)
              if (headerIndex !== null) {
                // 找到标准 WebM header，标记并准备发送
                hasFoundHeader.value = true
                console.warn(`✅ 找到标准 WebM header (1a45dfa3)（位置: ${headerIndex}），开始发送视频流数据`)

                // 如果 header 不在第一个数据块的开头，需要从 header 位置开始发送
                if (headerIndex > 0) {
                  // 合并缓冲区，从 header 位置开始
                  const totalLength = headerBuffer.value.reduce((sum, buf) => sum + buf.length, 0)
                  const merged = new Uint8Array(totalLength - headerIndex)
                  let offset = 0
                  let skipBytes = headerIndex
                  for (const buf of headerBuffer.value) {
                    if (skipBytes >= buf.length) {
                      skipBytes -= buf.length
                      continue
                    }
                    const bytesToCopy = buf.length - skipBytes
                    merged.set(buf.subarray(skipBytes), offset)
                    offset += bytesToCopy
                    skipBytes = 0
                  }
                  // 发送从 header 开始的数据
                  if (callbacks?.onChunk && merged.length > 0) {
                    callbacks.onChunk(merged.buffer)
                    chunkCount.value++
                    totalBytesSent.value += merged.length
                    lastChunkTime.value = now
                  }
                }
                else {
                  // header 在开头，发送所有累积的数据块
                  for (const buf of headerBuffer.value) {
                    if (callbacks?.onChunk) {
                      // 将 Uint8Array 转换为新的 ArrayBuffer
                      const buffer = new Uint8Array(buf).buffer
                      callbacks.onChunk(buffer)
                      chunkCount.value++
                      totalBytesSent.value += buf.length
                    }
                  }
                  lastChunkTime.value = now
                }
                // 清空缓冲区
                headerBuffer.value = []
                return
              }
              else {
                // 还没找到标准 WebM header，继续累积
                // 如果遇到异常 header (556f8100)，会被跳过，继续搜索真正的 WebM header
                console.warn(`⏳ 累积数据块 ${headerBuffer.value.length}/${MAX_HEADER_SEARCH_CHUNKS}，继续搜索标准 WebM header...`)
                return
              }
            }
          }

          // 已经找到 header，正常发送数据块
          // 如果之前累积了数据块但没找到 header（超过限制），现在发送累积的数据
          if (headerBuffer.value.length > 0) {
            for (const buf of headerBuffer.value) {
              if (callbacks?.onChunk) {
                // 将 Uint8Array 转换为新的 ArrayBuffer
                const buffer = new Uint8Array(buf).buffer
                callbacks.onChunk(buffer)
                chunkCount.value++
                totalBytesSent.value += buf.length
              }
            }
            headerBuffer.value = []
            // 注意：这里不更新 lastChunkTime，因为累积的数据块时间戳不准确
          }

          // 更新统计（当前数据块）
          chunkCount.value++
          totalBytesSent.value += chunkSize

          // 计算时间间隔
          lastChunkTime.value = now

          // 调用回调函数处理当前数据块
          if (callbacks?.onChunk) {
            callbacks.onChunk(arrayBuffer)
          }
        }
        catch (error) {
          console.error('处理视频数据块失败:', error)
          if (callbacks?.onError) {
            callbacks.onError(error instanceof Error ? error : new Error(String(error)))
          }
        }
      }

      // 处理录制错误
      recorder.onerror = (event) => {
        console.error('MediaRecorder 错误:', event)
        if (callbacks?.onError) {
          callbacks.onError(new Error('MediaRecorder 错误'))
        }
      }

      // 开始录制（每100ms获取一次数据块）
      recorder.start(100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键特性</strong>：</p>
<ul>
<li><strong>WebM Header 智能识别</strong>：实现了标准的 WebM header（0x1a45dfa3）检测机制，避免发送无效数据</li>
<li><strong>编码格式自动适配</strong>：支持 vp9、vp8、h264 等多种编码格式，自动选择浏览器支持的最佳格式</li>
<li><strong>分辨率自适应</strong>：使用 <code>ideal</code> 参数而非 <code>exact</code>，允许浏览器选择最接近的分辨率</li>
<li><strong>数据统计</strong>：实时统计比特率、帧数、数据量等信息</li>
</ul>
<p><strong>2. WebSocket 实时通信</strong></p>
<pre class="line-numbers language-114:233:apps/open-pro-client/src/stores/store-wave-awaken/store-wave-awaken.ts"><code class="language-114:233:apps/open-pro-client/src/stores/store-wave-awaken/store-wave-awaken.ts">  /** 连接挥手唤醒服务 */
  const connect = async () => {
    if (!window.__ELECTRON__)
      throw new Error('不能在非客户端环境下启动挥手唤醒服务')

    await stateChangePromise.value
    if (state.value === WebSocket.OPEN) {
      // eslint-disable-next-line no-console
      console.log('✅ 挥手唤醒服务已连接')
      return
    }

    // 从设置中获取 debug 配置
    const settingStore = useSettingStore()
    const debug = settingStore.settings['interaction:wave-awaken:debug'] ?? false

    // eslint-disable-next-line no-console
    console.log(`🔗 正在连接挥手唤醒服务: ws://${HOST}:${PORT}/ws/stream`)

    const { resolve, reject, promise } = createResolvers<WebSocket>()
    stateChangePromise.value = promise.finally(() => {
      stateChangePromise.value = null
    })

    state.value = WebSocket.CONNECTING
    const socket = new WebSocket(`ws://${HOST}:${PORT}/ws/stream?debug=${debug}`)
    const controller = new AbortController()

    socket.addEventListener('open', () => {
      window.$message?.success('挥手唤醒服务已连接')
      state.value = WebSocket.OPEN
      waveAwakenSocket.value = socket
      // 延迟一小段时间，确保服务器准备好接收数据
      // 这可以避免服务器在处理第一个数据块时出现索引越界错误
      setTimeout(() => {
        serverReady.value = true
        // eslint-disable-next-line no-console
        console.log('✅ 服务器已准备好接收视频数据')
      }, 500)
      controller.abort()
      resolve(socket)
      subjects.value.open.next(socket)
    }, {
      once: true,
      signal: controller.signal,
    })

    socket.addEventListener('close', (event) => {
      const closeInfo = {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean,
        timestamp: new Date().toISOString(),
      }

      // 根据关闭代码判断错误类型
      let errorMessage = ''
      if (event.code === 1011) {
        // 1011 表示服务器内部错误
        errorMessage = `服务器内部错误: ${event.reason || '未知错误'}`
        console.error('[挥手服务WebSocket连接异常关闭]', closeInfo)
        window.$message?.error(errorMessage)
      }
      else if (event.code === 1006) {
        // 1006 表示异常关闭（没有收到关闭帧）
        errorMessage = '连接异常断开，请检查网络连接'
        console.warn('⚠️ [挥手服务WebSocket连接异常断开]', closeInfo)
        window.$message?.warning(errorMessage)
      }
      else if (!event.wasClean && event.code !== 1000) {
        // 非正常关闭
        errorMessage = `连接关闭: ${event.reason || `错误代码 ${event.code}`}`
        console.warn('⚠️ [挥手服务WebSocket连接已关闭]', closeInfo)
        if (event.reason) {
          window.$message?.warning(errorMessage)
        }
      }
      else {
        console.warn('[🔴 挥手服务WebSocket连接已关闭]', closeInfo)
      }

      state.value = WebSocket.CLOSED
      waveAwakenSocket.value = null
      serverReady.value = false
      subjects.value.close.next(socket)
    })

    socket.addEventListener('error', (event) => {
      console.error('❌ WebSocket连接错误', {
        event,
        readyState: socket.readyState,
        timestamp: new Date().toISOString(),
      })
      reject(new Error('Connect error'))
    }, {
      once: true,
      signal: controller.signal,
    })

    socket.addEventListener('message', (ev: MessageEvent<string>) => {
      subjects.value.message.next(ev)
    })

    try {
      await promise
    }
    catch (error) {
      // 连接失败时，仍然尝试启动摄像头（保持预览功能）
      console.warn('⚠️ WebSocket连接失败，但将继续启动摄像头以显示预览')
      await startCamera().catch((err) => {
        console.error('启动摄像头失败:', err)
      })
      throw error
    }

    // 连接成功后，确保摄像头已启动
    await startCamera().catch((err) => {
      console.error('启动摄像头失败:', err)
    })
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术亮点</strong>：</p>
<ul>
<li><strong>状态管理完善</strong>：使用 <code>serverReady</code> 标志位控制数据发送时机，避免服务器未准备好时发送数据</li>
<li><strong>错误处理健壮</strong>：针对不同的 WebSocket 错误码提供详细的错误提示</li>
<li><strong>容错机制</strong>：WebSocket 连接失败时仍保持摄像头预览功能</li>
</ul>
<hr>
<h3 id="1-3-3D-模型渲染"><a href="#1-3-3D-模型渲染" class="headerlink" title="1.3 3D 模型渲染"></a>1.3 3D 模型渲染</h3><p>项目使用 Three.js 实现 3D 模型的加载、渲染和交互，支持 GLB 格式的模型文件。</p>
<pre class="line-numbers language-1:268:apps/open-pro-client/src/ui/ui-three3d/ui-three3d.vue"><code class="language-1:268:apps/open-pro-client/src/ui/ui-three3d/ui-three3d.vue"><script setup lang="ts">
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'

const props = defineProps<{
  modelUrl?: string
}>()

const containerRef = shallowRef<HTMLElement>()
const baseUrl = import.meta.env?.BASE_URL || '/'
const defaultModelUrl = `${baseUrl}3d_models/ZTZ99A.glb`
const modelUrl = computed(() => props.modelUrl ? `${baseUrl}3d_models/${props.modelUrl}` : defaultModelUrl)
console.log('【3D模型地址】', modelUrl.value)
// 场景、相机、渲染器
let scene: THREE.Scene | null = null
let camera: THREE.PerspectiveCamera | null = null
let renderer: THREE.WebGLRenderer | null = null
let controls: InstanceType<typeof OrbitControls> | null = null
let model: THREE.Group | null = null
let animationId: number | null = null

// 旋转控制参数
const rotationSpeed = ref(10) // 旋转速度（度/秒）
const rotationAngle = ref(0) // 当前旋转角度（度）
const isAnimationEnabled = ref(true) // 动画开关状态
const zoomFactor = ref(0.5) // 缩放因子
const cameraHeightFactor = ref(-0.2) // 相机高度因子（控制上下角度，值越大越俯视，值越小越仰视）
interface ModelSize {
  maxDim: number
  center: THREE.Vector3
}
const modelSize = ref<ModelSize | null>(null)

// 动画循环时间记录
let lastTime = performance.now()

// 更新相机位置
const updateCameraPosition = () => {
  if (!camera || !controls || !modelSize.value)
    return

  const distance = modelSize.value.maxDim * zoomFactor.value
  camera.position.set(distance, distance * cameraHeightFactor.value, distance)
  camera.lookAt(0, 0, 0)
  controls.target.set(0, 0, 0)
  controls.update()
}

// 加载 3D 模型
const loadModel = () => {
  if (!scene)
    return

  const loader = new GLTFLoader()

  loader.load(
    modelUrl.value,
    (gltf: { scene: THREE.Group }) => {
      if (!scene)
        return

      scene.add(gltf.scene)
      model = gltf.scene

      // 计算模型边界并调整位置
      const box = new THREE.Box3().setFromObject(gltf.scene)
      const center = box.getCenter(new THREE.Vector3())
      const size = box.getSize(new THREE.Vector3())

      // 将模型移动到场景中心
      gltf.scene.position.x = -center.x
      gltf.scene.position.y = -center.y
      gltf.scene.position.z = -center.z

      // 保存模型尺寸信息
      modelSize.value = {
        maxDim: Math.max(size.x, size.y, size.z),
        center,
      }

      // 调整相机位置以适应模型
      updateCameraPosition()
    },
    (progress: { loaded: number, total: number }) => {
      const percent = ((progress.loaded / progress.total) * 100).toFixed(2)
      // 加载进度日志
      if (percent)
        void percent
    },
    (error: Error) => {
      console.error('模型加载失败:', error)
    },
  )
}

// 动画循环
const animate = () => {
  if (!scene || !camera || !renderer)
    return

  animationId = requestAnimationFrame(animate)

  const currentTime = performance.now()
  const deltaTime = (currentTime - lastTime) / 1000 // 转换为秒
  lastTime = currentTime

  // 如果模型已加载且动画启用，让它自动360度旋转
  if (model && isAnimationEnabled.value && rotationSpeed.value > 0) {
    // 更新旋转角度（360度循环）
    rotationAngle.value += rotationSpeed.value * deltaTime
    // 保持角度在0-360度范围内
    if (rotationAngle.value >= 360) {
      rotationAngle.value -= 360
    }
    // 转换为弧度并应用旋转
    model.rotation.y = (rotationAngle.value * Math.PI) / 180
  }

  if (controls) {
    controls.update() // 更新控制器
  }
  renderer.render(scene, camera)
}

// 初始化 Three.js 场景
const initScene = () => {
  if (!containerRef.value)
    return

  // 创建场景
  scene = new THREE.Scene()
  // scene.background = new THREE.Color(0x87CEEB) // 天蓝色背景
  scene.background = null // 透明背景

  // 创建相机
  const width = containerRef.value.clientWidth
  const height = containerRef.value.clientHeight
  camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000)
  camera.position.set(2, 2, 3)

  // 创建渲染器
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
  renderer.setSize(width, height)
  renderer.shadowMap.enabled = true
  containerRef.value.appendChild(renderer.domElement)

  // 创建控制器
  controls = new OrbitControls(camera, renderer.domElement)
  controls.enableDamping = true
  controls.dampingFactor = 0.05
  // 限制上下旋转角度（可选，取消注释以启用限制）
  // controls.minPolarAngle = Math.PI / 6 // 最小角度（30度，防止旋转到模型下方）
  // controls.maxPolarAngle = Math.PI / 2 // 最大角度（90度，水平视角）

  // 添加灯光
  // 前方灯光（正Z方向）
  const lightFront = new THREE.DirectionalLight(0xFFFFFF, 0.8)
  lightFront.position.set(0, 2, 5)
  lightFront.castShadow = true
  scene.add(lightFront)

  // 后方灯光（负Z方向）
  const lightBack = new THREE.DirectionalLight(0xFFFFFF, 0.6)
  lightBack.position.set(0, 2, -5)
  lightBack.castShadow = true
  scene.add(lightBack)

  // 左侧灯光（负X方向）
  const lightLeft = new THREE.DirectionalLight(0xFFFFFF, 0.7)
  lightLeft.position.set(-5, 2, 0)
  lightLeft.castShadow = true
  scene.add(lightLeft)

  // 右侧灯光（正X方向）
  const lightRight = new THREE.DirectionalLight(0xFFFFFF, 0.7)
  lightRight.position.set(5, 2, 0)
  lightRight.castShadow = true
  scene.add(lightRight)

  // 环境光
  const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.4)
  scene.add(ambientLight)

  // 加载模型
  loadModel()

  // 开始动画循环
  animate()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术特性</strong>：</p>
<ul>
<li><strong>自动居中算法</strong>：通过计算模型边界框，自动将模型移动到场景中心</li>
<li><strong>自适应相机距离</strong>：根据模型尺寸动态调整相机位置</li>
<li><strong>四方向光源系统</strong>：前方、后方、左侧、右侧四个方向光源 + 环境光，确保模型各角度都有良好的光照</li>
<li><strong>OrbitControls 交互</strong>：支持鼠标拖拽、缩放、旋转等操作</li>
<li><strong>自动旋转动画</strong>：支持可配置的自动旋转速度和开关</li>
</ul>
<hr>
<h3 id="1-4-项目亮点特性"><a href="#1-4-项目亮点特性" class="headerlink" title="1.4 项目亮点特性"></a>1.4 项目亮点特性</h3><h4 id="1-🎯-双模式交互支持"><a href="#1-🎯-双模式交互支持" class="headerlink" title="1. 🎯 双模式交互支持"></a>1. 🎯 双模式交互支持</h4><ul>
<li><strong>纯软模式 (Soft)</strong>: 支持单轮/多轮对话，完整的语音唤醒流程</li>
<li><strong>软硬一体模式 (Soft-Hardware)</strong>: 结合人脸识别，支持无唤醒直接交互</li>
</ul>
<h4 id="2-🤖-多种唤醒方式"><a href="#2-🤖-多种唤醒方式" class="headerlink" title="2. 🤖 多种唤醒方式"></a>2. 🤖 多种唤醒方式</h4><ul>
<li><strong>语音唤醒</strong>: 通过本地语音唤醒服务检测唤醒词</li>
<li><strong>挥手唤醒</strong>: 通过摄像头视频流检测挥手动作</li>
<li><strong>人脸唤醒</strong>: 检测到人脸后自动进入交互状态</li>
<li><strong>点击唤醒</strong>: 点击屏幕触发区域唤醒</li>
</ul>
<h4 id="3-🎨-丰富的多模态展示"><a href="#3-🎨-丰富的多模态展示" class="headerlink" title="3. 🎨 丰富的多模态展示"></a>3. 🎨 丰富的多模态展示</h4><ul>
<li><strong>文本</strong>: 实时字幕显示</li>
<li><strong>图片</strong>: 全屏或气泡模式展示</li>
<li><strong>视频</strong>: 支持视频播放</li>
<li><strong>3D 模型</strong>: 集成 Three.js 渲染 3D 模型</li>
<li><strong>链接</strong>: 支持外部链接跳转</li>
</ul>
<h4 id="4-🔄-智能状态管理"><a href="#4-🔄-智能状态管理" class="headerlink" title="4. 🔄 智能状态管理"></a>4. 🔄 智能状态管理</h4><ul>
<li><strong>生命周期锁</strong>: 防止状态冲突和资源泄漏</li>
<li><strong>优雅中断</strong>: 支持打断正在进行的操作</li>
<li><strong>自动清理</strong>: 状态切换时自动清理资源</li>
</ul>
<h4 id="5-📹-摄像头流优化"><a href="#5-📹-摄像头流优化" class="headerlink" title="5. 📹 摄像头流优化"></a>5. 📹 摄像头流优化</h4><ul>
<li><strong>自动格式检测</strong>: 智能识别视频格式并适配</li>
<li><strong>分辨率优化</strong>: 自动查找支持 640x480 的摄像头</li>
<li><strong>编码转换</strong>: 实时软件转码，兼容性更好</li>
</ul>
<h4 id="6-🎭-待机模式多样化"><a href="#6-🎭-待机模式多样化" class="headerlink" title="6. 🎭 待机模式多样化"></a>6. 🎭 待机模式多样化</h4><ul>
<li><strong>仅动作</strong>: 数字人循环动作</li>
<li><strong>语料轮播</strong>: 展示配置的语料内容</li>
<li><strong>图片/视频</strong>: 全屏展示待机素材</li>
<li><strong>闲时播报</strong>: 定时播报预设内容</li>
</ul>
<hr>
<h2 id="二、技术难点与解决方案"><a href="#二、技术难点与解决方案" class="headerlink" title="二、技术难点与解决方案"></a>二、技术难点与解决方案</h2><h3 id="2-1-摄像头视频数据获取的踩坑经验"><a href="#2-1-摄像头视频数据获取的踩坑经验" class="headerlink" title="2.1 摄像头视频数据获取的踩坑经验"></a>2.1 摄像头视频数据获取的踩坑经验</h3><h4 id="问题一：摄像头硬件编码限制"><a href="#问题一：摄像头硬件编码限制" class="headerlink" title="问题一：摄像头硬件编码限制"></a>问题一：摄像头硬件编码限制</h4><p><strong>问题描述</strong>：</p>
<ul>
<li>普通 UVC 摄像头硬件只支持 MJPG 或 YUY2 输出</li>
<li>不支持 VP8/VP9/H.264 硬件编码</li>
<li>getUserMedia 获取的是硬件原生格式</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 1. getUserMedia 不指定编码格式，让摄像头输出原生格式</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> await <span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  video<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token punctuation">{</span> ideal<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token punctuation">{</span> ideal<span class="token punctuation">:</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 不指定 codec/format</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 2. MediaRecorder 进行软件转码</span>
<span class="token keyword">const</span> recorder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaRecorder</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  mimeType<span class="token punctuation">:</span> <span class="token string">"video/webm;codecs=vp9"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指定转码目标格式</span>
  videoBitsPerSecond<span class="token punctuation">:</span> <span class="token number">2500000</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键理解</strong>：</p>
<ul>
<li><strong>硬件层</strong>：摄像头输出 MJPG/YUY2（原生格式）</li>
<li><strong>软件层</strong>：MediaRecorder 实时转码为 VP9/H.264 等格式</li>
<li><strong>性能影响</strong>：软件转码消耗 CPU，需权衡性能和兼容性</li>
</ul>
<h4 id="问题二：WebM-Header-分片问题"><a href="#问题二：WebM-Header-分片问题" class="headerlink" title="问题二：WebM Header 分片问题"></a>问题二：WebM Header 分片问题</h4><p><strong>问题描述</strong>：</p>
<ul>
<li>MediaRecorder 输出的数据块可能不包含完整 header</li>
<li>Header 可能被分割到多个数据块中</li>
<li>直接发送数据可能导致解码失败</li>
<li>某些浏览器还会产生异常 header（如 0x556f8100）</li>
</ul>
<p><strong>解决方案</strong>：<br>实现了一个智能的 header 搜索机制：</p>
<ol>
<li><strong>累积缓冲策略</strong>：在找到有效 header 之前，累积前 5 个数据块</li>
<li><strong>标准 Header 检测</strong>：只接受标准的 WebM header（0x1a45dfa3），跳过异常数据</li>
<li><strong>超时保护</strong>：如果累积超过 5 个数据块仍未找到 header，强制开始发送（避免无限等待）</li>
<li><strong>数据对齐</strong>：如果 header 不在第一个数据块开头，从 header 位置开始发送，确保数据完整性</li>
</ol>
<pre class="line-numbers language-183:286:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-183:286:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">      // 在缓冲区中搜索 WebM header
      // 只接受标准 WebM header: 1a 45 df a3 (0x1a45dfa3)
      // 异常 header (556f8100) 可能是编码器产生的无效数据，应该跳过并继续搜索真正的 WebM header
      const findWebMHeaderInBuffer = (buffers: Uint8Array[]): number | null => {
        // 合并所有缓冲区
        const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0)
        if (totalLength < 4) {
          return null
        }
        const merged = new Uint8Array(totalLength)
        let offset = 0
        for (const buf of buffers) {
          merged.set(buf, offset)
          offset += buf.length
        }
        // 在合并的缓冲区中搜索标准 WebM header: 1a 45 df a3
        for (let i = 0; i <= merged.length - 4; i++) {
          // 只接受标准 WebM header
          if (merged[i] === 0x1A && merged[i + 1] === 0x45 && merged[i + 2] === 0xDF && merged[i + 3] === 0xA3) {
            return i
          }
          // 如果遇到异常 header (556f8100)，跳过它继续搜索（不返回）
          // 这样可以避免将无效数据当作有效 header
        }
        return null
      }

      // 处理视频数据块
      recorder.ondataavailable = async (event) => {
        if (!event.data || event.data.size === 0) {
          return
        }

        try {
          const now = Date.now()
          const chunkSize = event.data.size

          // 将 Blob 转换为 ArrayBuffer
          const arrayBuffer = await event.data.arrayBuffer()
          const uint8Array = new Uint8Array(arrayBuffer)

          // 如果还没有找到包含 header 的数据块，累积并搜索
          if (!hasFoundHeader.value) {
            // 将当前数据块添加到缓冲区
            headerBuffer.value.push(uint8Array)

            // 如果累积的数据块数量超过限制，强制开始发送（防止无限等待）
            if (headerBuffer.value.length > MAX_HEADER_SEARCH_CHUNKS) {
              console.warn('⚠️ 已累积多个数据块但未找到 header，开始发送数据（可能 header 已被分割）')
              hasFoundHeader.value = true
            }
            else {
              // 在累积的缓冲区中搜索 header
              const headerIndex = findWebMHeaderInBuffer(headerBuffer.value)
              if (headerIndex !== null) {
                // 找到标准 WebM header，标记并准备发送
                hasFoundHeader.value = true
                console.warn(`✅ 找到标准 WebM header (1a45dfa3)（位置: ${headerIndex}），开始发送视频流数据`)

                // 如果 header 不在第一个数据块的开头，需要从 header 位置开始发送
                if (headerIndex > 0) {
                  // 合并缓冲区，从 header 位置开始
                  const totalLength = headerBuffer.value.reduce((sum, buf) => sum + buf.length, 0)
                  const merged = new Uint8Array(totalLength - headerIndex)
                  let offset = 0
                  let skipBytes = headerIndex
                  for (const buf of headerBuffer.value) {
                    if (skipBytes >= buf.length) {
                      skipBytes -= buf.length
                      continue
                    }
                    const bytesToCopy = buf.length - skipBytes
                    merged.set(buf.subarray(skipBytes), offset)
                    offset += bytesToCopy
                    skipBytes = 0
                  }
                  // 发送从 header 开始的数据
                  if (callbacks?.onChunk && merged.length > 0) {
                    callbacks.onChunk(merged.buffer)
                    chunkCount.value++
                    totalBytesSent.value += merged.length
                    lastChunkTime.value = now
                  }
                }
                else {
                  // header 在开头，发送所有累积的数据块
                  for (const buf of headerBuffer.value) {
                    if (callbacks?.onChunk) {
                      // 将 Uint8Array 转换为新的 ArrayBuffer
                      const buffer = new Uint8Array(buf).buffer
                      callbacks.onChunk(buffer)
                      chunkCount.value++
                      totalBytesSent.value += buf.length
                    }
                  }
                  lastChunkTime.value = now
                }
                // 清空缓冲区
                headerBuffer.value = []
                return
              }
              else {
                // 还没找到标准 WebM header，继续累积
                // 如果遇到异常 header (556f8100)，会被跳过，继续搜索真正的 WebM header
                console.warn(`⏳ 累积数据块 ${headerBuffer.value.length}/${MAX_HEADER_SEARCH_CHUNKS}，继续搜索标准 WebM header...`)
                return
              }
            }
          }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="问题三：设备能力检测不准确"><a href="#问题三：设备能力检测不准确" class="headerlink" title="问题三：设备能力检测不准确"></a>问题三：设备能力检测不准确</h4><p><strong>问题描述</strong>：</p>
<ul>
<li><code>getCapabilities()</code> 返回的最大分辨率不一定可用</li>
<li>某些设备声称支持但实际应用失败</li>
<li>不同浏览器的 capabilities 实现不一致</li>
</ul>
<p><strong>解决方案</strong>：多策略验证</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 策略 1: 先检查 capabilities</span>
<span class="token keyword">const</span> capabilities <span class="token operator">=</span> videoTrack<span class="token punctuation">.</span><span class="token function">getCapabilities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>maxWidth <span class="token operator">>=</span> <span class="token number">640</span> <span class="token operator">&amp;&amp;</span> maxHeight <span class="token operator">>=</span> <span class="token number">480</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 策略 2: 尝试 applyConstraints</span>
  await videoTrack<span class="token punctuation">.</span><span class="token function">applyConstraints</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 策略 3: 验证实际结果</span>
  <span class="token keyword">const</span> actualSettings <span class="token operator">=</span> videoTrack<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>actualSettings<span class="token punctuation">.</span>width <span class="token operator">===</span> <span class="token number">640</span> <span class="token operator">&amp;&amp;</span> actualSettings<span class="token punctuation">.</span>height <span class="token operator">===</span> <span class="token number">480</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> deviceId<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 验证通过</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 策略 4: 直接 getUserMedia 验证</span>
<span class="token keyword">const</span> testStream <span class="token operator">=</span> await <span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  deviceId<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> deviceId <span class="token punctuation">}</span><span class="token punctuation">,</span>
  width<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  height<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="问题四：不同约束类型的行为差异"><a href="#问题四：不同约束类型的行为差异" class="headerlink" title="问题四：不同约束类型的行为差异"></a>问题四：不同约束类型的行为差异</h4><p><strong>Exact 约束</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>
  width<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    exact<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>✅ 严格要求，不满足则失败</li>
<li>❌ 兼容性最差，容易失败</li>
<li>🎯 用于精确控制分辨率</li>
</ul>
<p><strong>Min 约束</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token punctuation">{</span> width<span class="token punctuation">:</span> <span class="token punctuation">{</span> min<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">,</span> ideal<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>✅ 保证最低要求</li>
<li>⚠️ 可能返回更高分辨率（如 1920x1080）</li>
<li>🎯 用于确保质量底线</li>
</ul>
<p><strong>Ideal 约束</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>
  width<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ideal<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>✅ 兼容性最好</li>
<li>❌ 不保证结果</li>
<li>🎯 用于降级兼容</li>
</ul>
<h4 id="问题五：编码格式兼容性"><a href="#问题五：编码格式兼容性" class="headerlink" title="问题五：编码格式兼容性"></a>问题五：编码格式兼容性</h4><p><strong>问题描述</strong>：<br>不同浏览器对视频编码格式的支持差异较大，Chrome 支持 vp9/vp8，而某些浏览器可能只支持 h264 或 mp4。</p>
<p><strong>解决方案</strong>：<br>实现编码格式自动检测和降级策略：</p>
<pre class="line-numbers language-44:60:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-44:60:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">  /** 检查浏览器支持的视频编码格式 */
  const getSupportedMimeType = (): string | null => {
    const types = [
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm;codecs=h264',
      'video/webm',
      'video/mp4',
    ]

    for (const type of types) {
      if (MediaRecorder.isTypeSupported(type)) {
        return type
      }
    }
    return null
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优先级策略</strong>：</p>
<ol>
<li>vp9（最佳压缩率）</li>
<li>vp8（较好压缩率）</li>
<li>h264（广泛兼容）</li>
<li>webm（无 codec 指定，浏览器自动选择）</li>
<li>mp4（最后备选）</li>
</ol>
<p><strong>浏览器兼容性对比</strong>：</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>H.264 支持</th>
<th>VP9 支持</th>
<th>getCapabilities</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Firefox</td>
<td>⚠️ 部分</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Safari</td>
<td>✅</td>
<td>❌</td>
<td>⚠️ 部分</td>
</tr>
<tr>
<td>Edge</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h4 id="问题六：运行时格式切换"><a href="#问题六：运行时格式切换" class="headerlink" title="问题六：运行时格式切换"></a>问题六：运行时格式切换</h4><p><strong>问题描述</strong>：</p>
<ul>
<li>初始创建的 MediaRecorder 可能使用了不兼容的格式</li>
<li>需要在运行时检测数据格式并切换编码器</li>
<li>切换过程中不能中断数据流</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 1. 检测到不兼容格式</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>detectedFormat <span class="token operator">!==</span> <span class="token string">"webm"</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasTriedH264<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 2. 标记已尝试，避免无限循环</span>
  hasTriedH264 <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 3. 停止当前 recorder</span>
  recorder<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 4. 创建新 recorder（stream 不变）</span>
  <span class="token keyword">const</span> newRecorder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaRecorder</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    mimeType<span class="token punctuation">:</span> <span class="token function">getSupportedMimeType</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 强制 H.264</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 5. 重新设置事件处理器</span>
  <span class="token function">setupRecorderHandlers</span><span class="token punctuation">(</span>newRecorder<span class="token punctuation">,</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 6. 重置状态</span>
  hasFoundHeader <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
  headerBuffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  detectedFormat <span class="token operator">=</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 7. 开始新的录制</span>
  newRecorder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="问题七：分辨率适配"><a href="#问题七：分辨率适配" class="headerlink" title="问题七：分辨率适配"></a>问题七：分辨率适配</h4><p><strong>问题描述</strong>：<br>不同摄像头的支持分辨率不同，如果强制指定 <code>exact</code> 分辨率，可能导致获取失败。</p>
<p><strong>解决方案</strong>：<br>使用 <code>ideal</code> 参数而非 <code>exact</code>，允许浏览器选择最接近的支持分辨率：</p>
<pre class="line-numbers language-117:124:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-117:124:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 },
        },
        audio: false,
      })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>自动适配硬件能力</li>
<li>避免因分辨率不匹配导致的获取失败</li>
<li>可通过 <code>getSettings()</code> 获取实际应用的分辨率</li>
</ul>
<h4 id="问题八：摄像头权限与错误处理"><a href="#问题八：摄像头权限与错误处理" class="headerlink" title="问题八：摄像头权限与错误处理"></a>问题八：摄像头权限与错误处理</h4><p><strong>问题描述</strong>：<br>不同操作系统和浏览器对摄像头权限的处理方式不同，错误信息不够友好。</p>
<p><strong>常见错误类型</strong>：</p>
<table>
<thead>
<tr>
<th>错误名称</th>
<th>原因</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>NotAllowedError</code></td>
<td>用户拒绝权限</td>
<td>提示用户授权</td>
</tr>
<tr>
<td><code>NotFoundError</code></td>
<td>未找到摄像头</td>
<td>检查硬件连接</td>
</tr>
<tr>
<td><code>OverconstrainedError</code></td>
<td>约束无法满足</td>
<td>降级到更宽松的约束</td>
</tr>
<tr>
<td><code>NotReadableError</code></td>
<td>设备被占用</td>
<td>提示关闭其他应用</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>API 不支持</td>
<td>检查浏览器兼容性</td>
</tr>
</tbody></table>
<p><strong>解决方案</strong>：<br>实现详细的错误分类和用户友好的提示：</p>
<pre class="line-numbers language-337:368:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-337:368:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">    catch (error) {
      console.error('❌ 启动摄像头失败:', error)
      if (error instanceof Error) {
        // 记录详细的错误信息
        const errorDetails = {
          name: error.name,
          message: error.message,
          stack: error.stack,
        }
        console.error('错误详情:', errorDetails)

        // 如果是 "Could not start video source" 错误，提供更详细的错误信息
        if (error.message.includes('Could not start video source')) {
          const enhancedError = new Error(
            `Could not start video source: 摄像头可能被其他应用占用、权限未授予或硬件故障。原始错误: ${error.message}`,
          )
          enhancedError.name = error.name
          if (callbacks?.onError) {
            callbacks.onError(enhancedError)
          }
          stopCamera()
          throw enhancedError
        }

        if (callbacks?.onError) {
          callbacks.onError(error)
        }
      }
      // 清理资源
      stopCamera()
      throw error
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Electron 主进程中也处理了 macOS 的权限请求：</p>
<pre class="line-numbers language-44:58:apps/open-pro-client/electron/main/index.ts"><code class="language-44:58:apps/open-pro-client/electron/main/index.ts">  app.whenReady().then(async () => {
    // 在 macOS 上主动请求摄像头权限
    if (process.platform === 'darwin') {
      try {
        const cameraStatus = systemPreferences.getMediaAccessStatus('camera')
        if (cameraStatus !== 'granted') {
          const isAuthorized = await systemPreferences.askForMediaAccess('camera')
          if (!isAuthorized) {
            console.warn('⚠️ 摄像头权限未授予，请在系统设置中授予权限')
          }
        }
      }
      catch (error) {
        console.error('请求摄像头权限失败:', error)
      }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="2-2-复杂状态机的设计与管理"><a href="#2-2-复杂状态机的设计与管理" class="headerlink" title="2.2 复杂状态机的设计与管理"></a>2.2 复杂状态机的设计与管理</h3><h4 id="状态机架构"><a href="#状态机架构" class="headerlink" title="状态机架构"></a>状态机架构</h4><p>项目采用了基于 RxJS 的响应式状态机，管理数字人交互的完整生命周期。状态包括：</p>
<ul>
<li><code>none</code>: 初始状态</li>
<li><code>standby</code>: 待机状态</li>
<li><code>focus</code>: 聚焦状态（人脸进入时）</li>
<li><code>awaken</code>: 唤醒状态（语音/挥手唤醒）</li>
<li><code>listen</code>: 监听状态（等待语音输入）</li>
<li><code>transition</code>: 过渡状态</li>
<li><code>speech</code>: 发言状态（数字人正在说话）</li>
<li><code>exit</code>: 退出状态</li>
<li><code>idle</code>: 空闲状态</li>
</ul>
<h4 id="状态锁机制"><a href="#状态锁机制" class="headerlink" title="状态锁机制"></a>状态锁机制</h4><p>为了防止状态竞争和确保状态转换的原子性，实现了 <code>StageLock</code> 机制：</p>
<pre class="line-numbers language-9:120:apps/open-pro-client/src/stores/store-state/store-state.ts"><code class="language-9:120:apps/open-pro-client/src/stores/store-state/store-state.ts">/** 生命周期锁 */
interface StageLock {
  /** 锁 id，用于内部状态管理 */
  id: string
  /** 锁所属的周期名称 */
  name: App.StageName
  /** 锁的取消信号 */
  signal: AbortSignal
  /** 锁释放/取消时兑现的 promise, 成功兑现时返回释放原因 */
  finished: Promise<string | Error>
  /** 取消此锁 */
  abort: <T>(reason: T) => void
  /** 返回此锁是否已经被释放 */
  isReleased: () => boolean
  /**
   * 释放此锁，返回释放是否成功的标志，如果释放失败，表示此锁已被释放或取消
   * @param {string} type 参数用于调试
   */
  release: (type?: string) => boolean
  /**
   * 在触发清理方法时调用
   */
  onDispose: (callback: () => void) => {
    off: () => void
  }
  /**
   * 在离开作用域时自动清理锁
   * @note 在被闭包持有时会失效，请慎重处理闭包情况！
   */
  [Symbol.dispose]: () => void
}

const createId = () => {
  return [...
(num => num.toString(16).padStart(2, '0'))
    .join('')


export const useStateStore = defineStore('state', () => {
  const devStore = useDevStore()
  const userStore = useUserStore()

  const subjects = shallowRef({
    stage: new Subject<App.Stage>(),
    /** 数字人生命周期改变时 */
    stageChange: new Subject<App.StageName>(),
    /** 每次触发【交互】时（此行为流用于重置回到待机状态的定时器） */
    interaction: new Subject<void>(),
  } as const)

  /** 当前生命周期 */
  const currentStage = ref<App.StageName>('none')

  /** 生命周期原子锁 */



  /** 获取生命周期锁 */
  const getStageLock = (name: App.StageName): StageLock | undefined => {
    if (stageLock.value)
      return
    const lockId = createId()
    const controller = new AbortController()

    const { resolve, promise } = createResolvers<string | Error>()
    const lock: StageLock = {
      id: lockId,
      name,
      signal: controller.signal,
      finished: promise,
      abort: (reason) => {
        if (controller.signal.aborted)
          return
        devStore.log.info('stage', 'abort', reason, name)
        controller.abort(reason)
        stageLock.value = null
        try {
          controller.signal.throwIfAborted()
        }
        catch (err) {
          resolve(err instanceof Error ? err : new Error(JSON.stringify(err)))
        }
        disposeHook.trigger()
        console.groupEnd()
      },
      isReleased: () => {
        return controller.signal.aborted || (lockId !== stageLock.value?.id)
      },
      release: (type = 'release') => {
        if (lockId !== stageLock.value?.id)
          return false
        stageLock.value = null
        resolve(type)
        devStore.log.info('stage', type, name)
        console.groupEnd()
        return true
      },
      onDispose: disposeHook.on,
      [Symbol.dispose]: () => {
        try {
          disposeHook.trigger()
          lock.release('dispose')
        }
        catch {
          // 忽略
        }
      },
    }
    stageLock.value = lock
    console.group(`stage: "${name}"`)
    devStore.log.info('stage', 'getLock', name)
    return lock
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="状态打断机制"><a href="#状态打断机制" class="headerlink" title="状态打断机制"></a>状态打断机制</h4><p>支持在任意状态通过 <code>abort</code> 方法打断当前状态，并触发状态转换：</p>
<pre class="line-numbers language-235:244:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue"><code class="language-235:244:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue">// 语音唤醒可以跳过 [focus]，直接进入 [awaken] 状态
// FIXME: 需要打断发言的唤醒流依然存在问题，待优化
useSubscription(awakenStore.subjects.awake.subscribe(async (data) => {
  // 已处于 [awaken] 状态时不能递归进入
  if (stateStore.stageLock?.name === 'awaken') {
    devStore.log.info('语音唤醒', '不能递归唤醒', data)
    return
  }
  devStore.log.info('语音唤醒', data)
  stateStore.stageLock?.abort(STAGE_REASON.AWAKEN)
  stateStore.subjects.stage.next({ name: 'awaken' })
}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术亮点</strong>：</p>
<ul>
<li><strong>原子性保证</strong>：通过锁机制确保状态转换的原子性</li>
<li><strong>可中断性</strong>：支持异步操作的打断（基于 AbortController）</li>
<li><strong>资源清理</strong>：状态切换时自动清理资源（通过 <code>onDispose</code> 钩子）</li>
<li><strong>调试友好</strong>：提供详细的状态转换日志</li>
</ul>
<hr>
<h3 id="2-3-异步操作的时序管理"><a href="#2-3-异步操作的时序管理" class="headerlink" title="2.3 异步操作的时序管理"></a>2.3 异步操作的时序管理</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>一个完整的交互流程涉及多个异步环节：</p>
<ol>
<li>人脸识别（异步）</li>
<li>语音唤醒（异步）</li>
<li>语音识别（异步）</li>
<li>数字人驱动（异步）</li>
<li>流式对话（异步）</li>
</ol>
<p>这些环节可能相互打断，需要谨慎处理时序。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 RxJS 的 <code>switchMap</code>、<code>takeUntil</code>、<code>race</code> 等操作符管理异步流程：</p>
<pre class="line-numbers language-338:359:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue"><code class="language-338:359:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue">// ### 3. 进入到 [awaken] 状态
// - 进行 [唤醒响应] 动作，动作结束后进入 [listen] 状态
useSubscription(awaken$.subscribe(async () => {
  try {
    const lock = stateStore.getStageLock('awaken')
    if (!lock)
      return

    if (wakeupGuideText.value) {
      if (ttsaStore.voiceState !== 'idle')
        await ttsaStore.interrupt()
      await ttsaStore.speak(wakeupGuideText.value)
    }

    if (!lock.release())
      return
    stateStore.subjects.stage.next({ name: 'listen' })
  }
  catch (err) {
    switchStageByReason(err)
  }
}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键技巧</strong>：</p>
<ol>
<li><strong>使用 <code>takeUntil</code> 实现可中断</strong>：当状态被 <code>abort</code> 时，自动取消未完成的异步操作</li>
<li><strong>使用 <code>race</code> 实现超时</strong>：多个异步操作竞争，最先完成的触发后续流程</li>
<li><strong>使用 <code>switchMap</code> 取消前一个</strong>：状态切换时自动取消前一个状态的异步操作</li>
</ol>
<hr>
<h3 id="2-4-多模态内容同步渲染"><a href="#2-4-多模态内容同步渲染" class="headerlink" title="2.4 多模态内容同步渲染"></a>2.4 多模态内容同步渲染</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>数字人发言、图片、视频、3D 模型、链接等多模态内容需要同步展示，且要支持打断和切换。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><strong>事件驱动架构</strong>: 通过 TTSA SDK 的 widget 回调统一处理多模态事件</li>
<li><strong>状态清理机制</strong>: 状态切换时自动清理正在展示的物料</li>
<li><strong>气泡模式与全屏模式</strong>: 根据配置动态切换展示方式</li>
</ul>
<p><strong>关键代码位置</strong>:</p>
<ul>
<li><code>src/pages/home/components/interaction/interaction-mode-soft.vue</code> - 多模态事件处理</li>
<li><code>src/stores/store-state/hooks/useMeterialPlay.ts</code> - 物料播放控制</li>
</ul>
<h3 id="2-5-语音识别适配层设计"><a href="#2-5-语音识别适配层设计" class="headerlink" title="2.5 语音识别适配层设计"></a>2.5 语音识别适配层设计</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>不同服务商（腾讯、瓦力）的语音识别 API 差异很大，需要统一接口。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><strong>适配器模式</strong>: 定义 <code>SpeechRecognizerEngine</code> 标准接口</li>
<li><strong>三阶段事件</strong>: start → update → finish 统一事件流</li>
<li><strong>RxJS 流式处理</strong>: 通过 Observable 处理实时识别结果</li>
</ul>
<p><strong>关键代码位置</strong>:</p>
<ul>
<li><code>src/core/speech-recognizer/types.ts</code> - 接口定义</li>
<li><code>src/stores/store-asr/</code> - 各服务商适配实现</li>
</ul>
<hr>
<h3 id="2-6-数字人交互流程"><a href="#2-6-数字人交互流程" class="headerlink" title="2.6 数字人交互流程"></a>2.6 数字人交互流程</h3><h4 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h4><p>数字人交互系统采用状态机模式，通过 9 个核心状态管理完整的交互生命周期：</p>
<pre class="line-numbers language-mermaid"><code class="language-mermaid">graph TB
    Start([应用启动]) --> Login{用户登录}
    Login -->|登录成功| Init[初始化服务]
    Init --> TTSA[连接数字人服务]
    TTSA --> Awaken[启动语音唤醒]
    TTSA --> Face[启动人脸识别]
    TTSA --> ASR[启动语音识别]
    Awaken --> Standby[进入待机状态]
    Face --> Standby

    Standby -->|人脸进入| Focus[焦点状态]
    Standby -->|语音唤醒| AwakenState[唤醒状态]
    Standby -->|挥手唤醒| AwakenState
    Standby -->|点击屏幕| Focus

    Focus -->|打招呼完成| Idle[就绪状态]

    Idle -->|语音唤醒| AwakenState
    Idle -->|超时| Standby

    AwakenState -->|唤醒响应完成| Listen[倾听状态]

    Listen -->|识别到内容| Transition[过渡状态]
    Listen -->|识别为空| Idle
    Listen -->|命中退出词| Exit[退出状态]
    Listen -->|超时| Idle

    Transition -->|获取回答| Speech[发言状态]

    Speech -->|单轮模式| Standby
    Speech -->|多轮模式| Listen
    Speech -->|命中退出词| Exit

    Exit -->|退出完成| Standby

    style Standby fill:#e1f5ff
    style Focus fill:#fff4e1
    style Idle fill:#f0f9ff
    style AwakenState fill:#ffe1f5
    style Listen fill:#e1ffe1
    style Transition fill:#f5e1ff
    style Speech fill:#ffe1e1
    style Exit fill:#ffe1e1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="纯软模式-Soft-Mode-详细流程"><a href="#纯软模式-Soft-Mode-详细流程" class="headerlink" title="纯软模式 (Soft Mode) 详细流程"></a>纯软模式 (Soft Mode) 详细流程</h4><p>纯软模式需要语音唤醒才能开始交互，支持单轮和多轮对话：</p>
<pre class="line-numbers language-mermaid"><code class="language-mermaid">sequenceDiagram
    participant User as 用户
    participant App as 应用
    participant Face as 人脸识别
    participant Awaken as 语音唤醒
    participant ASR as 语音识别
    participant TTSA as 数字人服务
    participant LLM as 大模型

    User->>App: 启动应用
    App->>TTSA: 初始化数字人
    App->>Awaken: 启动语音唤醒
    App->>Face: 启动人脸识别
    App->>ASR: 启动语音识别
    App->>App: 进入待机状态

    alt 人脸进入
        Face->>App: 检测到人脸
        App->>App: 进入焦点状态
        App->>TTSA: 播放打招呼语料
        TTSA->>App: 播放完成
        App->>App: 进入就绪状态
    end

    alt 语音唤醒
        User->>Awaken: 说唤醒词
        Awaken->>App: 触发唤醒事件
        App->>App: 进入唤醒状态
        App->>TTSA: 播放唤醒响应
        TTSA->>App: 播放完成
        App->>App: 进入倾听状态
    end

    App->>ASR: 启动语音识别
    User->>ASR: 说话
    ASR->>App: 实时识别结果
    ASR->>App: 识别完成

    alt 识别到内容
        App->>App: 进入过渡状态
        App->>LLM: 发送问题
        LLM->>TTSA: 流式返回回答
        TTSA->>App: 开始发言
        App->>App: 进入发言状态
        TTSA->>App: 发言完成

        alt 单轮对话
            App->>App: 返回待机状态
        else 多轮对话
            App->>App: 返回倾听状态
        end
    else 识别为空
        App->>App: 返回就绪状态
    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="软硬一体模式-Soft-Hardware-Mode-详细流程"><a href="#软硬一体模式-Soft-Hardware-Mode-详细流程" class="headerlink" title="软硬一体模式 (Soft-Hardware Mode) 详细流程"></a>软硬一体模式 (Soft-Hardware Mode) 详细流程</h4><p>软硬一体模式结合人脸识别，检测到人脸后可直接交互，无需唤醒词：</p>
<pre class="line-numbers language-mermaid"><code class="language-mermaid">sequenceDiagram
    participant User as 用户
    participant App as 应用
    participant Face as 人脸识别
    participant ASR as 语音识别
    participant TTSA as 数字人服务
    participant LLM as 大模型

    User->>App: 启动应用
    App->>TTSA: 初始化数字人
    App->>Face: 启动人脸识别
    App->>ASR: 启动语音识别
    App->>App: 进入待机状态

    Face->>App: 检测到人脸
    App->>App: 进入焦点状态
    App->>TTSA: 播放打招呼语料
    TTSA->>App: 播放完成
    App->>App: 进入就绪状态
    App->>ASR: 自动启动识别

    User->>ASR: 直接说话（无需唤醒词）
    ASR->>App: 检测到语音开始
    App->>App: 进入倾听状态
    ASR->>App: 实时识别结果
    ASR->>App: 识别完成

    alt 识别到内容
        App->>App: 进入过渡状态
        App->>LLM: 发送问题
        LLM->>TTSA: 流式返回回答
        TTSA->>App: 开始发言
        App->>App: 进入发言状态
        TTSA->>App: 发言完成
        App->>App: 返回就绪状态
    else 识别为空
        App->>App: 返回就绪状态
    end

    Face->>App: 人脸离开
    App->>App: 进入退出状态
    App->>TTSA: 播放退出语料
    TTSA->>App: 播放完成
    App->>App: 返回待机状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="2-7-数字人状态详解"><a href="#2-7-数字人状态详解" class="headerlink" title="2.7 数字人状态详解"></a>2.7 数字人状态详解</h3><h4 id="状态总览"><a href="#状态总览" class="headerlink" title="状态总览"></a>状态总览</h4><p>数字人应用共有 <strong>9 个核心状态</strong>，每个状态都有明确的职责和转换条件：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>英文标识</th>
<th>说明</th>
<th>触发条件</th>
<th>下一状态</th>
</tr>
</thead>
<tbody><tr>
<td>不可用</td>
<td><code>none</code></td>
<td>应用未初始化或用户未登录</td>
<td>应用启动/用户登出</td>
<td><code>standby</code></td>
</tr>
<tr>
<td>待机</td>
<td><code>standby</code></td>
<td>展示待机内容，等待交互</td>
<td>登录成功/交互结束</td>
<td><code>focus</code>/<code>awaken</code></td>
</tr>
<tr>
<td>焦点</td>
<td><code>focus</code></td>
<td>检测到人脸，进行打招呼</td>
<td>人脸进入/点击屏幕</td>
<td><code>idle</code></td>
</tr>
<tr>
<td>就绪</td>
<td><code>idle</code></td>
<td>等待用户输入，可进行交互</td>
<td><code>focus</code> 完成</td>
<td><code>awaken</code>/<code>listen</code>/<code>standby</code></td>
</tr>
<tr>
<td>唤醒</td>
<td><code>awaken</code></td>
<td>响应唤醒词，播放唤醒语料</td>
<td>语音唤醒/挥手唤醒</td>
<td><code>listen</code></td>
</tr>
<tr>
<td>倾听</td>
<td><code>listen</code></td>
<td>正在识别用户语音输入</td>
<td><code>awaken</code> 完成/<code>idle</code> 触发</td>
<td><code>transition</code>/<code>idle</code>/<code>exit</code></td>
</tr>
<tr>
<td>过渡</td>
<td><code>transition</code></td>
<td>等待大模型生成回答</td>
<td><code>listen</code> 识别完成</td>
<td><code>speech</code></td>
</tr>
<tr>
<td>发言</td>
<td><code>speech</code></td>
<td>数字人正在发言</td>
<td><code>transition</code> 获取回答</td>
<td><code>listen</code>/<code>standby</code></td>
</tr>
<tr>
<td>退出</td>
<td><code>exit</code></td>
<td>播放退出语料</td>
<td>命中退出词/人脸离开</td>
<td><code>idle</code>/<code>standby</code></td>
</tr>
</tbody></table>
<h4 id="状态详细说明"><a href="#状态详细说明" class="headerlink" title="状态详细说明"></a>状态详细说明</h4><p><strong>1. <code>none</code> - 不可用状态</strong></p>
<ul>
<li><strong>职责</strong>: 应用初始状态，数字人服务未连接；用户未登录时的默认状态</li>
<li><strong>UI 表现</strong>: 不显示数字人，显示登录界面</li>
<li><strong>状态转换</strong>: → <code>standby</code>: 用户登录成功后</li>
</ul>
<p><strong>2. <code>standby</code> - 待机状态</strong></p>
<ul>
<li><strong>职责</strong>: 展示待机内容（动作/语料/图片/视频）；等待用户触发交互（人脸/语音/点击）</li>
<li><strong>UI 表现</strong>: 数字人循环播放待机动作；根据配置显示待机语料、图片或视频；显示欢迎气泡和快捷入口</li>
<li><strong>状态转换</strong>: → <code>focus</code>: 检测到人脸进入；→ <code>awaken</code>: 语音唤醒或挥手唤醒；→ <code>focus</code>: 点击屏幕触发区域</li>
<li><strong>超时机制</strong>: 无超时，持续待机直到触发交互</li>
</ul>
<p><strong>3. <code>focus</code> - 焦点状态</strong></p>
<ul>
<li><strong>职责</strong>: 检测到用户（人脸/点击）后的响应；播放打招呼语料，吸引用户注意</li>
<li><strong>UI 表现</strong>: 数字人播放打招呼动作和语音；显示欢迎气泡</li>
<li><strong>状态转换</strong>: → <code>idle</code>: 打招呼语料播放完成</li>
</ul>
<p><strong>4. <code>idle</code> - 就绪状态</strong></p>
<ul>
<li><strong>职责</strong>: 等待用户输入（语音唤醒或直接说话）；在软硬一体模式下，自动启动语音识别</li>
<li><strong>UI 表现</strong>: 数字人保持就绪姿态；显示欢迎气泡</li>
<li><strong>状态转换</strong>: → <code>awaken</code>: 语音唤醒触发；→ <code>listen</code>: 软硬一体模式下检测到语音开始；→ <code>standby</code>: 超时（240 秒提示 + 60 秒等待）</li>
<li><strong>超时机制</strong>: T1 = 240 秒：提示用户”60 秒内无交互将返回待机状态”；T2 = 60 秒：自动返回待机状态</li>
</ul>
<p><strong>5. <code>awaken</code> - 唤醒状态</strong></p>
<ul>
<li><strong>职责</strong>: 响应唤醒词，播放唤醒响应语料；准备进入语音识别状态</li>
<li><strong>UI 表现</strong>: 数字人播放唤醒响应动作和语音；显示唤醒提示</li>
<li><strong>状态转换</strong>: → <code>listen</code>: 唤醒响应播放完成</li>
<li><strong>打断机制</strong>: 如果数字人正在发言，会先打断当前发言</li>
</ul>
<p><strong>6. <code>listen</code> - 倾听状态</strong></p>
<ul>
<li><strong>职责</strong>: 启动语音识别，实时显示识别结果；等待用户完成语音输入</li>
<li><strong>UI 表现</strong>: 显示语音识别动效；实时显示识别文本（气泡模式或字幕模式）；显示停止按钮</li>
<li><strong>状态转换</strong>: → <code>transition</code>: 识别到有效内容；→ <code>idle</code>: 识别结果为空；→ <code>exit</code>: 命中退出关键词；→ <code>idle</code>: 超时（60 秒）</li>
<li><strong>超时机制</strong>: 15 秒后提示：”60 秒内未识别到内容将返回待机模式”；60 秒后自动返回 <code>idle</code> 状态</li>
</ul>
<p><strong>7. <code>transition</code> - 过渡状态</strong></p>
<ul>
<li><strong>职责</strong>: 将用户问题发送给大模型；等待大模型生成回答；播放过渡动作（可选）</li>
<li><strong>UI 表现</strong>: 数字人可能播放思考动作；显示加载提示</li>
<li><strong>状态转换</strong>: → <code>speech</code>: 获取到大模型回答，数字人开始发言；→ <code>idle</code>: 如果识别结果为空，返回就绪状态</li>
</ul>
<p><strong>8. <code>speech</code> - 发言状态</strong></p>
<ul>
<li><strong>职责</strong>: 数字人播放回答内容；支持流式发言和一次性发言；处理多模态内容（图片/视频/3D 模型/链接）</li>
<li><strong>UI 表现</strong>: 数字人发言动作和语音；显示字幕（非气泡模式）；显示多模态内容（图片/视频/3D 模型）；显示停止按钮</li>
<li><strong>状态转换</strong>: → <code>standby</code>: 单轮对话模式，发言完成；→ <code>listen</code>: 多轮对话模式，发言完成后继续倾听；→ <code>standby</code>: 命中退出关键词</li>
<li><strong>打断机制</strong>: 支持用户打断数字人发言；打断后根据模式返回相应状态</li>
</ul>
<p><strong>9. <code>exit</code> - 退出状态</strong></p>
<ul>
<li><strong>职责</strong>: 播放退出语料；清理当前会话；返回待机或就绪状态</li>
<li><strong>UI 表现</strong>: 数字人播放退出动作和语音；显示退出提示</li>
<li><strong>状态转换</strong>: → <code>idle</code>: 退出完成（软硬一体模式）；→ <code>standby</code>: 退出完成（纯软模式）</li>
<li><strong>触发条件</strong>: 命中退出关键词（如”再见”、”退出”等）；软硬一体模式下人脸离开</li>
</ul>
<hr>
<h2 id="三、技术经验总结"><a href="#三、技术经验总结" class="headerlink" title="三、技术经验总结"></a>三、技术经验总结</h2><h3 id="3-1-响应式编程的最佳实践"><a href="#3-1-响应式编程的最佳实践" class="headerlink" title="3.1 响应式编程的最佳实践"></a>3.1 响应式编程的最佳实践</h3><h4 id="RxJS-在项目中的应用"><a href="#RxJS-在项目中的应用" class="headerlink" title="RxJS 在项目中的应用"></a>RxJS 在项目中的应用</h4><p>项目大量使用 RxJS 管理异步事件流，主要应用场景：</p>
<ol>
<li><strong>状态流管理</strong>：通过 <code>Subject</code> 管理状态变更</li>
<li><strong>事件订阅</strong>：使用 <code>subscribe</code> 响应状态变化</li>
<li><strong>操作符组合</strong>：使用 <code>switchMap</code>、<code>filter</code>、<code>takeUntil</code> 等操作符处理复杂流程</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>代码清晰，逻辑链式表达</li>
<li>自动处理取消和清理</li>
<li>易于测试和调试</li>
</ul>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 挥手唤醒检测流程</span>
subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>message
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
    <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 解析 JSON 响应</span>
      <span class="token keyword">const</span> response <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> as WaveAwakenResponse<span class="token punctuation">;</span>
      <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">filter</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span> response is WaveAwakenResultResponse <span class="token operator">=</span><span class="token operator">></span>
        response <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        response<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"result"</span> <span class="token operator">&amp;&amp;</span>
        response<span class="token punctuation">.</span>waving <span class="token operator">===</span> <span class="token keyword">true</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 触发唤醒事件</span>
    subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>awake<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-2-Electron-应用开发经验"><a href="#3-2-Electron-应用开发经验" class="headerlink" title="3.2 Electron 应用开发经验"></a>3.2 Electron 应用开发经验</h3><h4 id="主进程与渲染进程通信"><a href="#主进程与渲染进程通信" class="headerlink" title="主进程与渲染进程通信"></a>主进程与渲染进程通信</h4><p>项目使用 Electron 的 IPC 通信机制，通过 preload 脚本暴露安全的 API：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// preload/index.ts</span>
contextBridge<span class="token punctuation">.</span><span class="token function">exposeInMainWorld</span><span class="token punctuation">(</span><span class="token string">"__ELECTRON__"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">"awaken:launch"</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> ipcRenderer<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">"awaken:launch"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>在 Electron 中，需要主动请求系统权限（特别是 macOS）：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 在 app.whenReady() 时请求摄像头权限</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">===</span> <span class="token string">"darwin"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cameraStatus <span class="token operator">=</span> systemPreferences<span class="token punctuation">.</span><span class="token function">getMediaAccessStatus</span><span class="token punctuation">(</span><span class="token string">"camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cameraStatus <span class="token operator">!==</span> <span class="token string">"granted"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    await systemPreferences<span class="token punctuation">.</span><span class="token function">askForMediaAccess</span><span class="token punctuation">(</span><span class="token string">"camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-3-摄像头视频流处理最佳实践"><a href="#3-3-摄像头视频流处理最佳实践" class="headerlink" title="3.3 摄像头视频流处理最佳实践"></a>3.3 摄像头视频流处理最佳实践</h3><h4 id="1-权限管理"><a href="#1-权限管理" class="headerlink" title="1. 权限管理"></a>1. 权限管理</h4><p><strong>注意点</strong>：</p>
<ul>
<li>首次 <code>getUserMedia</code> 会触发权限请求</li>
<li>权限被拒绝后无法获取设备 label</li>
<li>需要优雅处理权限拒绝的情况</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 先请求一次权限</span>
  await navigator<span class="token punctuation">.</span>mediaDevices<span class="token punctuation">.</span><span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">{</span> video<span class="token punctuation">:</span> <span class="token keyword">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 权限失败，但继续尝试（可能只能获取 deviceId）</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 再枚举设备（此时可以获取 label）</span>
<span class="token keyword">const</span> devices <span class="token operator">=</span> await navigator<span class="token punctuation">.</span>mediaDevices<span class="token punctuation">.</span><span class="token function">enumerateDevices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-资源清理"><a href="#2-资源清理" class="headerlink" title="2. 资源清理"></a>2. 资源清理</h4><p><strong>注意点</strong>：</p>
<ul>
<li>MediaStream 的 track 必须手动停止</li>
<li>MediaRecorder 必须手动停止</li>
<li>定时器必须清除</li>
<li>避免内存泄漏</li>
</ul>
<p><strong>清理流程</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> stopCamera <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 1. 停止 MediaRecorder</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>mediaRecorder<span class="token punctuation">.</span>value<span class="token operator">?</span><span class="token punctuation">.</span>state <span class="token operator">!==</span> <span class="token string">"inactive"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mediaRecorder<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 2. 停止所有视频轨道</span>
  mediaStream<span class="token punctuation">.</span>value<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">getTracks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> track<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 3. 清除定时器</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>statsUpdateInterval<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>statsUpdateInterval<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 4. 重置所有状态</span>
  mediaRecorder<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  mediaStream<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  chunkCount<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// ... 其他状态重置</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h4><p><strong>数据块大小</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript">recorder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每 100ms 一个数据块</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>⬆️ 增大间隔：减少回调频率，降低 CPU 占用</li>
<li>⬇️ 减小间隔：降低延迟，但增加处理开销</li>
<li>🎯 建议：50-200ms 之间</li>
</ul>
<p><strong>比特率配置</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript">videoBitsPerSecond<span class="token punctuation">:</span> <span class="token number">2500000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2.5 Mbps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>640x480 @ 30fps：建议 1.5-3 Mbps</li>
<li>1920x1080 @ 30fps：建议 4-8 Mbps</li>
<li>权衡：画质 vs 带宽 vs CPU</li>
</ul>
<p><strong>编码格式选择</strong>：优先选择压缩率高的格式（vp9 &gt; vp8 &gt; h264）</p>
<h4 id="4-跨浏览器兼容性"><a href="#4-跨浏览器兼容性" class="headerlink" title="4. 跨浏览器兼容性"></a>4. 跨浏览器兼容性</h4><p><strong>API 支持检查</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 检查基础 API</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>navigator<span class="token punctuation">.</span>mediaDevices<span class="token operator">?</span><span class="token punctuation">.</span>getUserMedia<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"浏览器不支持 getUserMedia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 检查可选 API</span>
<span class="token keyword">const</span> capabilities <span class="token operator">=</span> videoTrack<span class="token punctuation">.</span>getCapabilities<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>capabilities<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 降级处理</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-移动端适配"><a href="#5-移动端适配" class="headerlink" title="5. 移动端适配"></a>5. 移动端适配</h4><p><strong>注意点</strong>：</p>
<ul>
<li>移动设备通常有前后两个摄像头</li>
<li>分辨率和帧率限制更严格</li>
<li>需要处理设备旋转</li>
</ul>
<p><strong>前后摄像头选择</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> constraints <span class="token operator">=</span> <span class="token punctuation">{</span>
  video<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    facingMode<span class="token punctuation">:</span> <span class="token punctuation">{</span> ideal<span class="token punctuation">:</span> <span class="token string">"user"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 'user' 前置, 'environment' 后置</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="6-调试技巧"><a href="#6-调试技巧" class="headerlink" title="6. 调试技巧"></a>6. 调试技巧</h4><p><strong>详细日志</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 设备信息</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"设备:"</span><span class="token punctuation">,</span> videoTrack<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"能力:"</span><span class="token punctuation">,</span> videoTrack<span class="token punctuation">.</span><span class="token function">getCapabilities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"设置:"</span><span class="token punctuation">,</span> videoTrack<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 数据格式</span>
<span class="token keyword">const</span> hexPreview <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"数据头:"</span><span class="token punctuation">,</span> hexPreview<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 统计信息</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"比特率:"</span><span class="token punctuation">,</span> currentBitrate<span class="token punctuation">,</span> <span class="token string">"Kbps"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"数据块数:"</span><span class="token punctuation">,</span> chunkCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"FPS:"</span><span class="token punctuation">,</span> currentFPS<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7-数据流处理流程图"><a href="#7-数据流处理流程图" class="headerlink" title="7. 数据流处理流程图"></a>7. 数据流处理流程图</h4><pre><code>┌─────────────────┐
│  摄像头硬件      │
│  (MJPG/YUY2)    │
└────────┬────────┘
         │ getUserMedia
         │ (原生格式)
         ▼
┌─────────────────┐
│  MediaStream    │
│  (Video Track)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ MediaRecorder   │
│ (软件转码)      │
│  VP9/VP8/H.264  │
└────────┬────────┘
         │ ondataavailable
         │ (每 100ms)
         ▼
┌─────────────────┐
│  Blob chunks    │
└────────┬────────┘
         │ arrayBuffer()
         ▼
┌─────────────────┐
│  ArrayBuffer    │
│  (WebM/H.264)   │
└────────┬────────┘
         │
         ├─► 格式检测
         ├─► Header 查找
         ├─► 统计更新
         └─► WebSocket 传输</code></pre><h3 id="3-4-性能优化策略"><a href="#3-4-性能优化策略" class="headerlink" title="3.4 性能优化策略"></a>3.4 性能优化策略</h3><h4 id="1-视频流优化（见-3-3-性能优化部分）"><a href="#1-视频流优化（见-3-3-性能优化部分）" class="headerlink" title="1. 视频流优化（见 3.3 性能优化部分）"></a>1. 视频流优化（见 3.3 性能优化部分）</h4><h4 id="2-3D-渲染优化"><a href="#2-3D-渲染优化" class="headerlink" title="2. 3D 渲染优化"></a>2. 3D 渲染优化</h4><ul>
<li><strong>按需渲染</strong>：只在模型可见时进行渲染</li>
<li><strong>资源清理</strong>：组件卸载时正确释放 Three.js 资源</li>
<li><strong>光照优化</strong>：使用环境光 + 方向光的组合，减少计算量</li>
</ul>
<h4 id="3-状态管理优化"><a href="#3-状态管理优化" class="headerlink" title="3. 状态管理优化"></a>3. 状态管理优化</h4><ul>
<li><strong>响应式更新</strong>：使用 <code>computed</code> 和 <code>watchEffect</code> 实现细粒度的响应式更新</li>
<li><strong>避免不必要的订阅</strong>：使用 <code>takeUntil</code> 及时取消订阅</li>
</ul>
<h3 id="3-5-关键代码片段"><a href="#3-5-关键代码片段" class="headerlink" title="3.5 关键代码片段"></a>3.5 关键代码片段</h3><h4 id="1-视频编码格式检测"><a href="#1-视频编码格式检测" class="headerlink" title="1. 视频编码格式检测"></a>1. 视频编码格式检测</h4><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> detectVideoFormat <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">:</span> Uint8Array<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// MJPEG: FF D8 FF</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xff</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xd8</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"mjpeg"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// WebM: 1A 45 DF A3</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x1a</span> <span class="token operator">&amp;&amp;</span>
    data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x45</span> <span class="token operator">&amp;&amp;</span>
    data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xdf</span> <span class="token operator">&amp;&amp;</span>
    data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xa3</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"webm"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// H.264: 00 00 00 01 或 00 00 01</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x00</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x00</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">||</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"h264"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-WebM-Header-查找算法"><a href="#2-WebM-Header-查找算法" class="headerlink" title="2. WebM Header 查找算法"></a>2. WebM Header 查找算法</h4><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> findWebMHeaderInBuffer <span class="token operator">=</span> <span class="token punctuation">(</span>buffers<span class="token punctuation">:</span> Uint8Array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 合并所有缓冲区</span>
  <span class="token keyword">const</span> totalLength <span class="token operator">=</span> buffers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> buf<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> sum <span class="token operator">+</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>totalLength <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> buf of buffers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    merged<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    offset <span class="token operator">+</span><span class="token operator">=</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 搜索 WebM header (0x1a45dfa3)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> merged<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      merged<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x1a</span> <span class="token operator">&amp;&amp;</span>
      merged<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x45</span> <span class="token operator">&amp;&amp;</span>
      merged<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xdf</span> <span class="token operator">&amp;&amp;</span>
      merged<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0xa3</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 header 位置</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 未找到</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-设备能力检测与分辨率适配"><a href="#3-设备能力检测与分辨率适配" class="headerlink" title="3. 设备能力检测与分辨率适配"></a>3. 设备能力检测与分辨率适配</h4><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token keyword">const</span> testDeviceCapabilities <span class="token operator">=</span> async <span class="token punctuation">(</span>deviceId<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 获取设备流</span>
  <span class="token keyword">const</span> testStream <span class="token operator">=</span> await <span class="token function">getUserMedia</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    deviceId<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> deviceId <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> videoTrack <span class="token operator">=</span> testStream<span class="token punctuation">.</span><span class="token function">getVideoTracks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> capabilities <span class="token operator">=</span> videoTrack<span class="token punctuation">.</span><span class="token function">getCapabilities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 检查是否支持目标分辨率</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>capabilities<span class="token punctuation">.</span>width<span class="token punctuation">.</span>max <span class="token operator">>=</span> <span class="token number">640</span> <span class="token operator">&amp;&amp;</span> capabilities<span class="token punctuation">.</span>height<span class="token punctuation">.</span>max <span class="token operator">>=</span> <span class="token number">480</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 尝试应用精确约束</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      await videoTrack<span class="token punctuation">.</span><span class="token function">applyConstraints</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token punctuation">{</span> exact<span class="token punctuation">:</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment" spellcheck="true">// 验证实际结果</span>
      <span class="token keyword">const</span> settings <span class="token operator">=</span> videoTrack<span class="token punctuation">.</span><span class="token function">getSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>settings<span class="token punctuation">.</span>width <span class="token operator">===</span> <span class="token number">640</span> <span class="token operator">&amp;&amp;</span> settings<span class="token punctuation">.</span>height <span class="token operator">===</span> <span class="token number">480</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> success<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> deviceId <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 精确约束失败，尝试降级</span>
      await videoTrack<span class="token punctuation">.</span><span class="token function">applyConstraints</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token punctuation">{</span> min<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">,</span> ideal<span class="token punctuation">:</span> <span class="token number">640</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token punctuation">{</span> min<span class="token punctuation">:</span> <span class="token number">480</span><span class="token punctuation">,</span> ideal<span class="token punctuation">:</span> <span class="token number">480</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> success<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span> deviceId <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="四、项目架构总结"><a href="#四、项目架构总结" class="headerlink" title="四、项目架构总结"></a>四、项目架构总结</h2><h3 id="4-1-目录结构"><a href="#4-1-目录结构" class="headerlink" title="4.1 目录结构"></a>4.1 目录结构</h3><pre><code>apps/open-pro-client/
├── electron/              # Electron 主进程代码
│   ├── main/             # 主线程
│   └── preload/          # 预加载脚本
├── src/
│   ├── apis/             # 后端接口
│   ├── core/             # 核心功能模块
│   │   ├── interaction-composite/    # 交互逻辑
│   │   ├── speech-recognizer/        # 语音识别引擎
│   │   └── ttsa-renderer/            # 数字人渲染器
│   ├── stores/           # 状态管理
│   │   ├── store-ttsa/               # 数字人状态
│   │   ├── store-wave-awaken/        # 挥手唤醒状态
│   │   ├── store-awaken/             # 语音唤醒状态
│   │   ├── store-asr/                # 语音识别状态
│   │   └── store-state/              # 应用状态机
│   ├── pages/            # 页面组件
│   └── ui/               # UI 组件
│       ├── ui-three3d/               # 3D 模型组件
│       └── ui-camera-preview/        # 摄像头预览组件
└── public/               # 静态资源
    ├── server/           # 本地服务（挥手唤醒服务等）
    └── weights/          # AI 模型文件</code></pre><h3 id="4-2-核心设计模式"><a href="#4-2-核心设计模式" class="headerlink" title="4.2 核心设计模式"></a>4.2 核心设计模式</h3><ol>
<li><strong>适配器模式</strong>：语音识别引擎适配层，统一不同服务商的接口</li>
<li><strong>观察者模式</strong>：使用 RxJS Subject 实现事件订阅</li>
<li><strong>状态机模式</strong>：通过 StageLock 管理复杂的状态流转</li>
<li><strong>组合模式</strong>：将多个功能模块组合成完整的交互流程</li>
</ol>
<h3 id="4-3-核心模块说明"><a href="#4-3-核心模块说明" class="headerlink" title="4.3 核心模块说明"></a>4.3 核心模块说明</h3><h4 id="1-状态管理模块"><a href="#1-状态管理模块" class="headerlink" title="1. 状态管理模块"></a>1. 状态管理模块</h4><p><strong>文件</strong>: <code>src/stores/store-state/store-state.ts</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>生命周期锁管理</li>
<li>状态转换控制</li>
<li>物料播放控制</li>
<li>会话记录管理</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 获取状态锁</span>
<span class="token keyword">const</span> lock <span class="token operator">=</span> stateStore<span class="token punctuation">.</span><span class="token function">getStageLock</span><span class="token punctuation">(</span><span class="token string">"listen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 释放状态锁</span>
lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 取消状态锁</span>
lock<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span>STAGE_REASON<span class="token punctuation">.</span>EXIT<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 切换状态</span>
stateStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>stage<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"speech"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2-数字人服务模块"><a href="#2-数字人服务模块" class="headerlink" title="2. 数字人服务模块"></a>2. 数字人服务模块</h4><p><strong>文件</strong>: <code>src/stores/store-ttsa/store-ttsa.ts</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>TTSA SDK 初始化和连接</li>
<li>数字人驱动（发言、动作）</li>
<li>多模态事件处理</li>
<li>视频流管理</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 数字人发言</span>
await ttsaStore<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token string">"你好，很高兴遇见你。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 打断发言</span>
ttsaStore<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 流式回答</span>
<span class="token keyword">const</span> stream <span class="token operator">=</span> await ttsaStore<span class="token punctuation">.</span><span class="token function">excuteStreamAnswer</span><span class="token punctuation">(</span><span class="token string">"用户问题"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-语音识别模块"><a href="#3-语音识别模块" class="headerlink" title="3. 语音识别模块"></a>3. 语音识别模块</h4><p><strong>文件</strong>: <code>src/stores/store-asr/</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>多服务商适配（腾讯、瓦力）</li>
<li>实时语音识别</li>
<li>识别结果事件流</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 启动识别</span>
asrStore<span class="token punctuation">.</span>engine<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 停止识别</span>
asrStore<span class="token punctuation">.</span>engine<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听识别结果</span>
asrStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>update<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"识别中:"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-语音唤醒模块"><a href="#4-语音唤醒模块" class="headerlink" title="4. 语音唤醒模块"></a>4. 语音唤醒模块</h4><p><strong>文件</strong>: <code>src/stores/store-awaken/store-awaken.ts</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>本地语音唤醒服务连接</li>
<li>唤醒词检测</li>
<li>WebSocket 通信</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 连接唤醒服务</span>
await awakenStore<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听唤醒事件</span>
awakenStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>awake<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"唤醒触发:"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-挥手唤醒模块"><a href="#5-挥手唤醒模块" class="headerlink" title="5. 挥手唤醒模块"></a>5. 挥手唤醒模块</h4><p><strong>文件</strong>: <code>src/stores/store-wave-awaken/store-wave-awaken.ts</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>摄像头视频流获取</li>
<li>视频流编码转换</li>
<li>挥手动作检测（后端服务）</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 连接挥手唤醒服务</span>
await waveAwakenStore<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 启动摄像头</span>
await waveAwakenStore<span class="token punctuation">.</span><span class="token function">startCamera</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听挥手唤醒</span>
waveAwakenStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>awake<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"挥手唤醒触发"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="6-人脸识别模块"><a href="#6-人脸识别模块" class="headerlink" title="6. 人脸识别模块"></a>6. 人脸识别模块</h4><p><strong>文件</strong>: <code>src/stores/store-face/store-face.ts</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>本地人脸识别（基于 face-api.js）</li>
<li>瓦力服务人脸识别</li>
<li>人脸进入/离开事件</li>
</ul>
<p><strong>关键 API</strong>:</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 启动人脸识别</span>
await faceStore<span class="token punctuation">.</span><span class="token function">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听人脸进入</span>
faceStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>faceEnter<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"检测到人脸"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听人脸离开</span>
faceStore<span class="token punctuation">.</span>subjects<span class="token punctuation">.</span>faceLeave<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"人脸离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="7-数字人渲染器"><a href="#7-数字人渲染器" class="headerlink" title="7. 数字人渲染器"></a>7. 数字人渲染器</h4><p><strong>文件</strong>: <code>src/core/ttsa-renderer/ttsa-renderer.vue</code></p>
<p><strong>核心功能</strong>:</p>
<ul>
<li>WebGL 视频流渲染</li>
<li>颜色抠除（背景透明）</li>
<li>实时帧回调</li>
</ul>
<p><strong>关键特性</strong>:</p>
<ul>
<li>支持自定义目标颜色抠除</li>
<li>可配置相似度、平滑度、饱和度</li>
<li>高性能实时渲染</li>
</ul>
<hr>
<h2 id="五、总结与展望"><a href="#五、总结与展望" class="headerlink" title="五、总结与展望"></a>五、总结与展望</h2><h3 id="5-1-项目亮点"><a href="#5-1-项目亮点" class="headerlink" title="5.1 项目亮点"></a>5.1 项目亮点</h3><ol>
<li><strong>多模态交互</strong>：集成语音、手势、人脸识别等多种交互方式</li>
<li><strong>实时性保证</strong>：WebSocket 实时通信，低延迟的视频流传输</li>
<li><strong>健壮性设计</strong>：完善的错误处理、状态管理、资源清理机制</li>
<li><strong>可扩展架构</strong>：模块化设计，易于扩展新功能</li>
</ol>
<h3 id="5-2-技术难点攻克"><a href="#5-2-技术难点攻克" class="headerlink" title="5.2 技术难点攻克"></a>5.2 技术难点攻克</h3><ol>
<li><strong>摄像头硬件编码限制</strong>：理解了硬件输出与软件转码的本质差异，成功实现 MediaRecorder 实时转码</li>
<li><strong>WebM Header 分片问题</strong>：实现了智能缓冲和标准 header 检测机制，确保数据完整性</li>
<li><strong>设备能力检测不准确</strong>：通过多策略验证确保分辨率适配的准确性</li>
<li><strong>约束类型行为差异</strong>：深入理解 exact/min/ideal 约束的行为差异，实现多级降级策略</li>
<li><strong>编码格式兼容性</strong>：实现了跨浏览器的编码格式自动检测和降级适配</li>
<li><strong>运行时格式切换</strong>：支持运行时动态切换 MediaRecorder 编码格式</li>
<li><strong>复杂状态管理</strong>：通过状态锁机制解决了异步操作的时序问题</li>
<li><strong>性能优化</strong>：通过多种优化策略保证了应用的流畅性</li>
</ol>
<h3 id="5-3-未来优化方向"><a href="#5-3-未来优化方向" class="headerlink" title="5.3 未来优化方向"></a>5.3 未来优化方向</h3><ol>
<li><strong>性能进一步提升</strong>：考虑使用 WebAssembly 加速视频处理</li>
<li><strong>错误恢复机制</strong>：增强网络异常、服务异常的自动恢复能力</li>
<li><strong>用户体验优化</strong>：增加更多的交互反馈和动画效果</li>
<li><strong>测试覆盖</strong>：增加单元测试和集成测试的覆盖率</li>
</ol>
<hr>
<h2 id="附录-A：关键代码文件索引"><a href="#附录-A：关键代码文件索引" class="headerlink" title="附录 A：关键代码文件索引"></a>附录 A：关键代码文件索引</h2><ul>
<li><strong>摄像头视频流管理</strong>: <code>src/stores/store-wave-awaken/useCameraStream.ts</code></li>
<li><strong>挥手唤醒服务</strong>: <code>src/stores/store-wave-awaken/store-wave-awaken.ts</code></li>
<li><strong>数字人渲染器</strong>: <code>src/core/ttsa-renderer/ttsa-renderer.vue</code></li>
<li><strong>3D 模型组件</strong>: <code>src/ui/ui-three3d/ui-three3d.vue</code></li>
<li><strong>状态机管理</strong>: <code>src/stores/store-state/store-state.ts</code></li>
<li><strong>交互逻辑</strong>: <code>src/pages/home/components/interaction/interaction-mode-soft-hardware.vue</code></li>
<li><strong>Electron 主进程</strong>: <code>electron/main/index.ts</code></li>
</ul>
<h2 id="附录-B：useCameraStream-核心功能总结"><a href="#附录-B：useCameraStream-核心功能总结" class="headerlink" title="附录 B：useCameraStream 核心功能总结"></a>附录 B：useCameraStream 核心功能总结</h2><h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h3><ol>
<li>✅ <strong>多策略适配</strong>：针对不同设备和浏览器提供多种降级方案</li>
<li>✅ <strong>格式智能检测</strong>：自动识别视频格式并动态切换编码器</li>
<li>✅ <strong>详细日志输出</strong>：便于调试和问题排查</li>
<li>✅ <strong>完善的错误处理</strong>：覆盖各种异常情况</li>
<li>✅ <strong>实时统计监控</strong>：提供码率、FPS 等关键指标</li>
</ol>
<h3 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h3><ul>
<li>🎯 理解硬件编码 vs 软件转码的本质差异</li>
<li>🎯 WebM Header 分片问题的巧妙解决</li>
<li>🎯 多级约束策略确保最大兼容性</li>
<li>🎯 运行时格式切换保证数据流连续性</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>📹 实时视频流传输（WebRTC、WebSocket）</li>
<li>🎥 视频录制和编码</li>
<li>🔍 摄像头设备管理和能力检测</li>
<li>📊 视频流质量监控</li>
</ul>
<h2 id="附录-C：测试建议"><a href="#附录-C：测试建议" class="headerlink" title="附录 C：测试建议"></a>附录 C：测试建议</h2><h3 id="测试矩阵"><a href="#测试矩阵" class="headerlink" title="测试矩阵"></a>测试矩阵</h3><p><strong>设备类型</strong>：</p>
<ul>
<li>✅ 内置摄像头</li>
<li>✅ USB 外接摄像头</li>
<li>✅ 虚拟摄像头（OBS）</li>
</ul>
<p><strong>浏览器</strong>：</p>
<ul>
<li>✅ Chrome/Edge</li>
<li>✅ Firefox</li>
<li>✅ Safari</li>
</ul>
<p><strong>分辨率</strong>：</p>
<ul>
<li>✅ 640x480</li>
<li>✅ 1280x720</li>
<li>✅ 1920x1080</li>
</ul>
<p><strong>网络条件</strong>：</p>
<ul>
<li>✅ 本地环境</li>
<li>✅ 弱网环境</li>
</ul>
<h3 id="关键测试点"><a href="#关键测试点" class="headerlink" title="关键测试点"></a>关键测试点</h3><ol>
<li><p><strong>权限测试</strong></p>
<ul>
<li>首次访问权限请求</li>
<li>拒绝权限后的处理</li>
<li>macOS/Windows 权限差异</li>
</ul>
</li>
<li><p><strong>设备兼容性测试</strong></p>
<ul>
<li>多摄像头设备切换</li>
<li>分辨率不支持的降级处理</li>
<li>编码格式自动适配</li>
</ul>
</li>
<li><p><strong>数据完整性测试</strong></p>
<ul>
<li>WebM Header 正确识别</li>
<li>数据块连续性</li>
<li>格式切换的平滑性</li>
</ul>
</li>
<li><p><strong>性能测试</strong></p>
<ul>
<li>CPU 占用率</li>
<li>内存使用</li>
<li>网络带宽消耗</li>
<li>帧率稳定性</li>
</ul>
</li>
<li><p><strong>异常处理测试</strong></p>
<ul>
<li>摄像头被占用</li>
<li>网络断开重连</li>
<li>服务器异常</li>
<li>浏览器崩溃恢复</li>
</ul>
</li>
</ol>
<hr>
<p><em>本文档基于项目实际代码总结，记录了开发过程中的技术难点、解决方案和经验总结，希望对后续开发和类似项目有所借鉴。</em></p>
<hr>
<p><em>最后更新：2025-12-17</em></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </code></pre></div><hr><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.88rem}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fa fa-close"></i></a><h4 class="reward-title">你的赏识是我前进的动力!</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/reward/alipay.bmp" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/reward/wechat.bmp" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div></div><script defer src="/libs/share/js/social-share.min.js"></script><div class="reprint1"><p><span class="reprint1-tip"><i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明: </span><a href="https://qindongxu-cn.github.io" class="b-link-green">秦东旭的博客</a> <i class="fa fa-angle-right fa-lg fa-fw text-color"></i> <a href="/2025/11/20/you-ling-pro-jun-gong-ding-zhi-hua-shu-zi-ren-da-ping-xiang-mu-ji-zhu-zong-jie/" class="b-link-green">有灵Pro：军工定制化数字人大屏项目技术总结</a></p></div></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div id="gitalk-container" class="card-content"></div></div><script defer src="/libs/gitalk/gitalk.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.Gitalk&&new Gitalk({clientID:"XXXXXXXXXXXXXXXXXXXXXXXXXXXX",clientSecret:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",repo:"shw2018.github.io",owner:"shw2018",admin:["shw2018"],id:"2025/11/20/you-ling-pro-jun-gong-ding-zhi-hua-shu-zi-ren-da-ping-xiang-mu-ji-zhu-zong-jie/",distractionFreeMode:!1}).render("gitalk-container")})</script><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url("") 100% 100% no-repeat}#vcomments input[type=email],#vcomments input[type=text],#vcomments input[type=url],#vcomments textarea{box-sizing:border-box}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#42b983;font-weight:500;text-decoration:underline}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div id="vcomments" class="card-content"></div></div><script defer src="/libs/valine/av-min.js"></script><script defer src="/libs/valine/Valine.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.Valine&&new Valine({el:"#vcomments",appId:"XXXXXXXXXXXXXXXXXXXXXXXX",appKey:"XXXXXXXXXXXXXXXXXXXXXX",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/2025/12/01/youling-pro/"><div class="card-image"><img src="/medias/featureimages/9.jpg" class="responsive-img" alt="有灵 Pro"> <span class="card-title">有灵 Pro</span></div></a><div class="card-content article-content"><div class="summary block-with-text">有灵 Pro 项目架构设计文档，包含目录结构、架构设计、开发难点和参考文档。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2025-12-01 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/" class="post-category" target="_blank">项目文档</a></span></div></div><div class="card-action article-tags"><a href="/tags/Electron/" target="_blank"><span class="chip bg-color">Electron</span> </a><a href="/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/" target="_blank"><span class="chip bg-color">语音识别</span> </a><a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" target="_blank"><span class="chip bg-color">人脸识别</span> </a><a href="/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/" target="_blank"><span class="chip bg-color">数字人</span> </a><a href="/tags/%E8%AF%AD%E9%9F%B3%E5%94%A4%E9%86%92/" target="_blank"><span class="chip bg-color">语音唤醒</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/2025/11/15/cicd-guide/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="前端项目容器化 CI/CD 配置指南：从入门到实战"> <span class="card-title">前端项目容器化 CI/CD 配置指南：从入门到实战</span></div></a><div class="card-content article-content"><div class="summary block-with-text">带你理解一套通俗易懂、可复用的前端 CI/CD（持续集成/持续部署）方案。核心思想是"配置即代码，环境全打包"，包含 GitLab CI、Docker、Nginx 等完整配置。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2025-11-15 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="post-category" target="_blank">前端工程化</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" target="_blank"><span class="chip bg-color">前端工程化</span> </a><a href="/tags/CI-CD/" target="_blank"><span class="chip bg-color">CI/CD</span> </a><a href="/tags/Docker/" target="_blank"><span class="chip bg-color">Docker</span> </a><a href="/tags/GitLab/" target="_blank"><span class="chip bg-color">GitLab</span> </a><a href="/tags/DevOps/" target="_blank"><span class="chip bg-color">DevOps</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0===window.getSelection||(""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: 秦东旭的博客<br />作者: 秦东旭<br />链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200))})</script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script defer src="/libs/tocbot/tocbot.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){if(void 0!==window.tocbot){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h1, h2, h3, h4, h5"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h1, h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget"),i=($(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")}),"expanded"),c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).slideUp(500),a.removeClass("l9")):(c.addClass(i).slideDown(500),a.addClass("l9"));var e="artDetail",n="prenext-posts";if(0!==(e=$("#"+e)).length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+n).width(t)}})}})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&copy; 2021 秦东旭. <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">滇ICP备2021008757号-1</a><br><span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span><br><span id="busuanzi_container_site_pv" style="display:none"></span> 总访问量: <span id="busuanzi_value_site_pv" class="white-color"></span> <span id="busuanzi_container_site_uv" style="display:none"></span> 人次&nbsp; | &nbsp;访客人数: <span id="busuanzi_value_site_uv" class="white-color"></span> 人 &nbsp; | &nbsp;字数统计:&nbsp; <span class="white-color">242.4k</span> 字<br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/shw2018" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=qindongxu1203@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i> </a><a href="https://zhihu.com/people/小当家" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50"><i class="fa fa-inverse">知</i> </a><a href="http://wpa.qq.com/msgrd?v=3&uin=1639758371&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50"><i class="fa fa-qq"></i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><script language="javascript">function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2021, 08, 10, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已勉强运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();</script><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script defer src="/js/search.js"></script><script type="text/javascript">document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.searchFunc&&searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script defer src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/masonry/4.2.2/masonry.pkgd.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/aos/3.0.0-beta.6/aos.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/scrollprogress/3.0.2/scrollProgress.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" crossorigin="anonymous"></script><script defer src="/js/matery.js"></script><script>window.__hexoLoadScript=function(t,e){var r,n;return t?(r=e||{},(n=document.createElement("script")).src=t,r.async&&(n.async=!0),!1!==r.defer&&(n.defer=!0),r.crossorigin&&(n.crossOrigin=r.crossorigin),r.attrs&&Object.keys(r.attrs).forEach(function(t){n.setAttribute(t,r.attrs[t])}),r.onLoad&&n.addEventListener("load",r.onLoad,{once:!0}),(r.target||document.body).appendChild(n),n):null}</script><script defer src="/libs/others/clicklove.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="看不见我🙈~看不见我🙈~",clearTimeout(st)):(document.title="(๑•̀ㅂ•́) ✧被发现了～",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript">(()=>{var e;window.innerWidth<=768||(e=function(){window.__hexoLoadScript("/js/sakura.js")},"complete"===document.readyState?e():window.addEventListener("load",e,{once:!0}))})()</script><script defer src="/js/wenzi.js" type="text/javascript"></script><script>(()=>{function e(){window.__hexoLoadScript("//code.tidio.co/xxxxxxxxxxxxxxxxxxxxxxxxxxx.js",{async:!0,defer:!1,crossorigin:"anonymous",onLoad:function(){var t=function(){if(void 0===window.jQuery)return window.setTimeout(t,100);function e(){var e,t,o,n=d("#tidio-chat iframe");n.length&&(o=(o=document.getElementById("tidio-chat-iframe"))||document.querySelector("#tidio-chat iframe"))&&"block"===n.css("display")&&(977<(e=window.innerWidth)?(o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-40px":document.querySelector("div.toc-title")&&977<e?"80px":"20px",o.style.right="-15px",t=parseInt(n.css("height"),10),o.style.height=520<=t?"520px":n.css("height"),o.style.zIndex="997"):601<e&&e<992?(o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-40px":"20px",o.style.right="-15px",o.style.zIndex="997"):e<=601&&(t=parseInt(n.css("height"),10),o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-10px":"45px",o.style.zIndex=230<=t?"998":"997"))}var d=window.jQuery;e(),window.addEventListener("resize",e),window.setInterval(e,200)};t()}})}"complete"===document.readyState?e():window.addEventListener("load",e,{once:!0})})()</script><script type="text/javascript">(()=>{var n;window.innerWidth<=992||(n=function(){window.__hexoLoadScript("/libs/background/ribbon.min.js",{attrs:{size:"150",alpha:"0.6",zIndex:"-1"}})},"complete"===document.readyState?n():window.addEventListener("load",n,{once:!0}))})()</script><script type="text/javascript">(()=>{var n;window.innerWidth<=992||(n=function(){window.__hexoLoadScript("/libs/background/ribbon-dynamic.js")},"complete"===document.readyState?n():window.addEventListener("load",n,{once:!0}))})()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>