<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="有灵Pro：军工定制化数字人大屏项目技术总结, UESTC CV DeepLearning MachineLearning 秦东旭 sunhw Hongwei 计算机视觉 深度学习"><meta name="baidu-site-verification" content="fmlEuI34ir"><meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY"><meta name="description" content="有灵 Pro：军工定制化数字人大屏项目技术总结项目概述有灵 Pro 是一款面向军工领域定制化的数字人大屏应用，基于 Electron + Vue 3 + TypeScript 构建。项目集成了数字人渲染、挥手唤醒、语音识别、人脸识别、3D "><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="preconnect" href="https://busuanzi.ibruce.info" crossorigin><link rel="dns-prefetch" href="//sdk.jinrishici.com"><link rel="preconnect" href="https://sdk.jinrishici.com" crossorigin><title>有灵Pro：军工定制化数字人大屏项目技术总结 | 秦东旭的博客</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/aos/3.0.0-beta.6/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script defer src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>window.addEventListener("load",function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",t.defer=!0,document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)})</script><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">秦东旭的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/AV" class="waves-effect waves-light"><i class="fa fa-music"></i> <span>视听</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/galleries" class="waves-effect waves-light"><i class="fa fa-photo"></i> <span>相册</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于我</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa fa-envelope"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa fa-address-book"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fa fa-search" title="搜索"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">秦东旭的博客</div><div class="logo-desc">上海市前端开发工程师</div></div><ul class="menu-list mobile-menu-list"><li><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li><a href="/AV" class="waves-effect waves-light"><i class="fa fa-fw fa-music"></i> 视听</a></li><li><a href="/galleries" class="waves-effect waves-light"><i class="fa fa-fw fa-photo"></i> 相册</a></li><li><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于我</a></li><li><a href="/contact" class="waves-effect waves-light"><i class="fa fa-fw fa-envelope"></i> 留言板</a></li><li><a href="/friends" class="waves-effect waves-light"><i class="fa fa-fw fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/qindongxu-cn/qindongxu-cn.github.io" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/qindongxu-cn/qindongxu-cn.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/8.jpg)"><div class="container"><div class="row"><div class="col s12 m12 l12"><div class="brand"><div class="description center-align post-title">有灵Pro：军工定制化数字人大屏项目技术总结</div></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}#floating-toc-btn{position:fixed;right:20px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Vue3/" target="_blank"><span class="chip bg-color">Vue3</span> </a><a href="/tags/Electron/" target="_blank"><span class="chip bg-color">Electron</span> </a><a href="/tags/Three-js/" target="_blank"><span class="chip bg-color">Three.js</span> </a><a href="/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/" target="_blank"><span class="chip bg-color">数字人</span> </a><a href="/tags/%E5%86%9B%E5%B7%A5%E9%A1%B9%E7%9B%AE/" target="_blank"><span class="chip bg-color">军工项目</span> </a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank"><span class="chip bg-color">技术总结</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-category" target="_blank">项目总结</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp; 2025-12-17</div><div class="post-author info-break-policy"><i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp; 秦东旭</div><div class="info-break-policy"><i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp; 8.7k</div><div class="info-break-policy"><i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp; 38 分</div><span id="busuanzi_container_site_pv" style="display:none"></span> <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="有灵-Pro：军工定制化数字人大屏项目技术总结"><a href="#有灵-Pro：军工定制化数字人大屏项目技术总结" class="headerlink" title="有灵 Pro：军工定制化数字人大屏项目技术总结"></a>有灵 Pro：军工定制化数字人大屏项目技术总结</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p><strong>有灵 Pro</strong> 是一款面向军工领域定制化的数字人大屏应用，基于 Electron + Vue 3 + TypeScript 构建。项目集成了数字人渲染、挥手唤醒、语音识别、人脸识别、3D 模型展示等多项核心技术，实现了智能化、多模态的人机交互体验。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li><strong>前端框架</strong>: Vue 3 + TypeScript + Vite</li><li><strong>桌面应用</strong>: Electron 36.4.0</li><li><strong>状态管理</strong>: Pinia + RxJS（响应式编程）</li><li><strong>3D 渲染</strong>: Three.js 0.181.2</li><li><strong>数字人驱动</strong>: TTSA SDK</li><li><strong>构建工具</strong>: Electron-Vite</li></ul><hr><h2 id="一、核心功能与技术亮点"><a href="#一、核心功能与技术亮点" class="headerlink" title="一、核心功能与技术亮点"></a>一、核心功能与技术亮点</h2><h3 id="1-1-数字人渲染与实时驱动"><a href="#1-1-数字人渲染与实时驱动" class="headerlink" title="1.1 数字人渲染与实时驱动"></a>1.1 数字人渲染与实时驱动</h3><h4 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h4><p>项目通过 TTSA SDK 实现数字人的实时渲染和驱动，核心逻辑位于 <code>src/stores/store-ttsa/</code>。</p><p><strong>关键特性</strong>：</p><ul><li><strong>流式对话驱动</strong>：支持流式文本驱动的数字人发言</li><li><strong>状态管理</strong>：通过 RxJS Subject 管理数字人生命周期事件</li><li><strong>视频帧回调</strong>：支持实时视频帧处理，实现背景抠除等效果</li></ul><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 数字人状态管理示例</span>
<span class="token keyword">const</span> ttsaStore <span class="token operator">=</span> <span class="token function">useTtsaStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> subjects <span class="token operator">=</span> ttsaStore<span class="token punctuation">.</span>subjects<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 监听数字人发言结束</span>
subjects<span class="token punctuation">.</span>voice_end<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 处理发言结束逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数字人渲染架构"><a href="#数字人渲染架构" class="headerlink" title="数字人渲染架构"></a>数字人渲染架构</h4><p>数字人渲染采用 <strong>WebGL + OGL</strong> 技术栈，实现了高性能的实时视频流处理和颜色抠除。</p><p><strong>核心流程</strong>：</p><ol><li><strong>视频帧获取</strong>：通过 <code>requestVideoFrameCallback</code> API 获取数字人视频流的每一帧</li><li><strong>WebGL 渲染</strong>：使用 OGL 库创建 WebGL 上下文，将视频帧作为纹理渲染到 Canvas</li><li><strong>实时抠色</strong>：通过 Fragment Shader 对每一帧进行颜色抠除处理</li><li><strong>透明背景</strong>：输出带有 Alpha 通道的透明背景，支持与页面其他元素融合</li></ol><h4 id="渲染原理详解"><a href="#渲染原理详解" class="headerlink" title="渲染原理详解"></a>渲染原理详解</h4><p><strong>1. 视频帧回调机制</strong></p><p>项目使用 <code>HTMLVideoElement.requestVideoFrameCallback()</code> API 实现高性能的视频帧捕获。相比传统的 <code>requestAnimationFrame</code>，该 API 专门为视频帧同步设计，能够精确地在每一帧视频刷新时触发回调，避免不必要的渲染：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 在 useAutoSetup.ts 中实现</span>
<span class="token keyword">const</span> frameCallback <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>frame<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 触发所有注册的视频帧回调</span>
  videoFrameCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callbacks<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span>ttsaVideo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 递归调用，形成循环</span>
  videoFrameCallbackId<span class="token punctuation">.</span>value <span class="token operator">=</span>
    ttsaVideo<span class="token punctuation">.</span><span class="token function">requestVideoFrameCallback</span><span class="token punctuation">(</span>frameCallback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
videoFrameCallbackId<span class="token punctuation">.</span>value <span class="token operator">=</span> ttsaVideo<span class="token punctuation">.</span><span class="token function">requestVideoFrameCallback</span><span class="token punctuation">(</span>frameCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优势</strong>：</p><ul><li><strong>帧精确同步</strong>：确保回调在视频帧刷新时触发，而不是浏览器渲染循环</li><li><strong>性能优化</strong>：自动跳过重复帧，只在视频实际更新时处理</li><li><strong>低延迟</strong>：相比 <code>requestAnimationFrame</code> 延迟更低</li></ul><p><strong>2. WebGL 渲染管线</strong></p><p>渲染器使用 <strong>OGL（轻量级 WebGL 库）</strong>构建渲染管线：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 创建渲染器（启用 Alpha 通道）</span>
<span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Renderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  canvas<span class="token punctuation">:</span> canvasRef<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
  width<span class="token punctuation">:</span> props<span class="token punctuation">.</span>width<span class="token punctuation">,</span>
  height<span class="token punctuation">:</span> props<span class="token punctuation">.</span>height<span class="token punctuation">,</span>
  alpha<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 支持透明背景</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 创建全屏四边形几何体</span>
<span class="token keyword">const</span> geometry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Geometry</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  a_position<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    size<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// NDC 坐标</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  a_texCoord<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    size<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 纹理坐标</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  index<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Uint16Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 索引</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 创建纹理（视频帧将作为纹理源）</span>
<span class="token keyword">const</span> texture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  generateMipmaps<span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">,</span>
  minFilter<span class="token punctuation">:</span> gl<span class="token punctuation">.</span>LINEAR<span class="token punctuation">,</span>
  magFilter<span class="token punctuation">:</span> gl<span class="token punctuation">.</span>LINEAR<span class="token punctuation">,</span>
  flipY<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 翻转 Y 轴，适配视频坐标系</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 颜色抠除算法原理</strong></p><p>颜色抠除在 Fragment Shader 中实现，核心算法基于 <strong>YUV 色度空间</strong>计算颜色相似度：</p><p><strong>步骤一：RGB 转 YUV 色度空间</strong></p><p>使用色度空间而非 RGB 空间，因为色度空间对亮度变化不敏感，更适合颜色匹配：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token keyword">vec2</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> rgb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">vec2</span><span class="token punctuation">(</span>
    rgb<span class="token punctuation">.</span>r <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.169</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.331</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>b <span class="token operator">*</span>  <span class="token number">0.5</span>    <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span>
    rgb<span class="token punctuation">.</span>r <span class="token operator">*</span>  <span class="token number">0.5</span>   <span class="token operator">+</span> rgb<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.419</span> <span class="token operator">+</span> rgb<span class="token punctuation">.</span>b <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.081</span>  <span class="token operator">+</span> <span class="token number">0.5</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤二：计算色度距离</strong></p><p>计算当前像素与目标颜色（绿幕）的色度向量距离：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// 计算色度向量差值</span>
<span class="token keyword">vec2</span> chromaVec <span class="token operator">=</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span>rgba<span class="token punctuation">.</span>rgb<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">RGBtoUV</span><span class="token punctuation">(</span>keyColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 计算色度距离（欧氏距离）</span>
<span class="token keyword">float</span> chromaDist <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>chromaVec<span class="token punctuation">,</span> chromaVec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤三：生成透明度遮罩</strong></p><p>根据色度距离和相似度阈值生成基础遮罩：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// baseMask 为负数：是绿幕（需要抠除）</span>
<span class="token comment" spellcheck="true">// baseMask 为正数：不是绿幕（保留）</span>
<span class="token keyword">float</span> baseMask <span class="token operator">=</span> chromaDist <span class="token operator">-</span> similarity<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 平滑过渡处理，生成最终的透明度</span>
<span class="token keyword">float</span> fullMask <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span>baseMask <span class="token operator">/</span> smoothness<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤四：边缘处理（Spill Suppression）</strong></p><p>绿幕边缘可能反射到前景物体上，产生绿色溢出。通过降低边缘区域的饱和度来消除：</p><pre class="line-numbers language-glsl"><code class="language-glsl"><span class="token comment" spellcheck="true">// 计算溢出值（距离绿幕越近，溢出值越小）</span>
<span class="token keyword">float</span> spillVal <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">clamp</span><span class="token punctuation">(</span>baseMask <span class="token operator">/</span> spill<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 计算灰度值</span>
<span class="token keyword">float</span> desat <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>rgba<span class="token punctuation">.</span>r <span class="token operator">*</span> <span class="token number">0.2126</span> <span class="token operator">+</span> rgba<span class="token punctuation">.</span>g <span class="token operator">*</span> <span class="token number">0.7152</span> <span class="token operator">+</span> rgba<span class="token punctuation">.</span>b <span class="token operator">*</span> <span class="token number">0.0722</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 根据溢出值混合原色和灰度，降低绿幕边缘的饱和度</span>
<span class="token keyword">return</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>
  <span class="token function">mix</span><span class="token punctuation">(</span><span class="token keyword">vec3</span><span class="token punctuation">(</span>desat<span class="token punctuation">,</span> desat<span class="token punctuation">,</span> desat<span class="token punctuation">)</span><span class="token punctuation">,</span> rgba<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> spillVal<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span>
  fullMask  <span class="token comment" spellcheck="true">// Alpha 通道</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完整 Shader 代码</strong>：</p><pre class="line-numbers language-1:63:apps/open-pro-client/src/core/ttsa-renderer/shaders/color-removal.fs.glsl"><code class="language-1:63:apps/open-pro-client/src/core/ttsa-renderer/shaders/color-removal.fs.glsl">#version 300 es
precision mediump float;
out vec4 FragColor;
in vec2 v_texCoord;

// 帧
uniform sampler2D frameTexture;
// 关键颜色
uniform vec3 keyColor;
// 色度的相似度计算
uniform float similarity;
// 透明度的平滑度计算
uniform float smoothness;
// 降低绿幕饱和度，提高抠图准确度
uniform float spill;
// 是否启用 0 - 禁用抠图  1 - 启用抠图
uniform float enable;

vec2 RGBtoUV(vec3 rgb) {
  return vec2(
    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,
    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5
  );
}

// 抠色逻辑
vec4 ColorRemoval(vec4 rgba) {
  // 计算当前像素与绿幕像素的色度差值
  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);

  // 计算当前像素与绿幕像素的色度距离（向量长度）, 越相像则色度距离越小
  float chromaDist = sqrt(dot(chromaVec, chromaVec));

  // 设置了一个相似度阈值, baseMask 为负，则表明是绿幕，为正则表明不是绿幕
  float baseMask = chromaDist - similarity;

  // 如果 baseMask 为负数, fullMask 等于 0; baseMask 为正数，越大，则透明度越低
  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);

  // 如果 baseMask 为负数, spillVal 等于 0; baseMask 为整数，越小，饱和度越低
  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);

  // 计算当前像素的灰度值
  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.);

  return vec4(
    mix(vec3(desat, desat, desat), rgba.rgb, spillVal).rgb,
    fullMask
  );
}

void main() {
  // 获取当前像素的 rgba 值
  vec4 rgba = texture(frameTexture, v_texCoord);

  if (enable == 0.0) {
    FragColor = rgba;
    return;
  }

  FragColor = ColorRemoval(rgba);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong>：</p><ul><li><strong>similarity</strong> (0-1)：颜色相似度阈值，值越大要求越精确匹配</li><li><strong>smoothness</strong> (0-1)：透明度过渡的平滑度，值越大边缘越柔和</li><li><strong>spill</strong> (0-1)：绿幕溢出抑制强度，值越小边缘去绿效果越强</li></ul><p><strong>4. 实时渲染循环</strong></p><p>每一帧视频更新时，将视频元素作为纹理源更新到 GPU，触发 Shader 处理：</p><pre class="line-numbers language-122:127:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><code class="language-122:127:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue">  attach((video) => {
    renderer.setSize(gl.canvas.width, gl.canvas.height)
    texture.image = video
    texture.needsUpdate = true
    renderer.render({ scene: mesh })
  })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>技术亮点</strong>：</p><ul><li><strong>高性能</strong>：GPU 加速处理，支持实时 60fps 渲染</li><li><strong>低延迟</strong>：使用 <code>requestVideoFrameCallback</code> 精确同步视频帧</li><li><strong>高质量</strong>：基于 YUV 色度空间的颜色匹配算法，对亮度变化不敏感</li><li><strong>边缘优化</strong>：Spill Suppression 技术消除绿幕边缘的绿色溢出</li><li><strong>可配置</strong>：支持实时调整抠除参数，适应不同场景需求</li></ul><p><strong>完整渲染器实现</strong>：</p><pre class="line-numbers language-12:147:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><code class="language-12:147:apps/open-pro-client/src/core/ttsa-renderer/ttsa-renderer.vue"><script setup lang="ts">
import { Geometry, Mesh, Program, Renderer, Texture } from 'ogl'
import { useMessage } from 'xmov-ui'
import { useDevStore, useSettingStore, useTtsaStore } from '@/stores'
import colorRemovalFrag from './shaders/color-removal.fs.glsl?raw'
import colorRemovalVert from './shaders/color-removal.vs.glsl?raw'

const props = defineProps<{
  width: number
  height: number
  /** 需要被抠除的目标颜色, 颜色值为 0 ~ 255 */
  targetColor?: [R: number, G: number, B: number]
  similarity?: number
  smoothness?: number
  spill?: number
}>()

// ============================== global store ==============================
const devStore = useDevStore()
const settingStore = useSettingStore()
const ttsaStore = useTtsaStore()
const message = useMessage()

// ============================== renderder ==============================
const canvasRef = shallowRef<HTMLCanvasElement>()

/** 是否启用颜色抠除 */
const colorRemovalEnable = computed(() => {
  return Number(settingStore.settings['appearence:bg-transparent-mode'] === 'removal')
})
/** 需要被抠除的目标颜色, 颜色值为 0 ~ 255 */
const targetColor = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:target-color']
})
/** 颜色相似度 0 ~ 1, 1 表示必须精确匹配 targetColor 指定的颜色值 */
const similarity = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:similarity']
})
/** 平滑度 0 ~ 1 */
const smoothness = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:smoothness']
})
/** 饱和度 0 ~ 1 */
const spill = computed(() => {
  return settingStore.settings['appearence:bg-transparent-removal:spill']
})

// ============================== draw control ==============================
const { attach, dismiss, pause, resume } = ttsaStore.useVideoFrameCallback()

onMounted(() => {
  if (!canvasRef.value) {
    message.error('渲染器容器未挂载')
    return
  }

  const renderer = new Renderer({
    canvas: canvasRef.value,
    width: props.width,
    height: props.height,
    alpha: true,
  })

  const { gl } = renderer

  const geometry = new Geometry(gl, {
    a_position: {
      size: 2,
      data: new Float32Array([-1, -1, +1, -1, +1, +1, -1, +1]),
    },
    a_texCoord: {
      size: 2,
      data: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    },
    index: {
      data: new Uint16Array([0, 1, 2, 0, 2, 3]),
    },
  })

  const texture = new Texture(gl, {
    generateMipmaps: false,
    minFilter: gl.LINEAR,
    magFilter: gl.LINEAR,
    flipY: true,
  })

  const program = new Program(gl, {
    vertex: colorRemovalVert,
    fragment: colorRemovalFrag,
    uniforms: {
      frameTexture: {
        value: texture,
      },
      keyColor: {
        value: targetColor.value,
      },
      similarity: {
        value: similarity.value,
      },
      smoothness: {
        value: smoothness.value,
      },
      spill: {
        value: spill.value,
      },
      enable: {
        value: colorRemovalEnable.value,
      },
    },
  })

  watchEffect(() => {
    program.uniforms.keyColor.value = targetColor.value
    program.uniforms.similarity.value = similarity.value
    program.uniforms.smoothness.value = smoothness.value
    program.uniforms.spill.value = spill.value
    program.uniforms.enable.value = colorRemovalEnable.value
  })

  const mesh = new Mesh(gl, { geometry, program })

  attach((video) => {
    renderer.setSize(gl.canvas.width, gl.canvas.height)
    texture.image = video
    texture.needsUpdate = true
    renderer.render({ scene: mesh })
  })
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键实现细节</strong>：</p>
<ul>
<li><strong>响应式参数更新</strong>：通过 <code>watchEffect</code> 实时更新 Shader 参数，无需重新编译</li>
<li><strong>生命周期管理</strong>：通过 <code>useVideoFrameCallback</code> 的 <code>attach</code>、<code>dismiss</code>、<code>pause</code>、<code>resume</code> 方法管理视频帧回调</li>
<li><strong>透明背景支持</strong>：启用 <code>alpha: true</code> 输出带有 Alpha 通道的透明背景</li>
</ul>
<hr>
<h3 id="1-2-挥手服务唤醒"><a href="#1-2-挥手服务唤醒" class="headerlink" title="1.2 挥手服务唤醒"></a>1.2 挥手服务唤醒</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>挥手唤醒服务采用<strong>客户端-服务器</strong>架构：</p>
<ul>
<li><strong>客户端</strong>：通过 WebSocket 实时传输摄像头视频流</li>
<li><strong>服务器</strong>：Python 后端服务，基于手势识别算法检测挥手动作</li>
<li><strong>通信协议</strong>：WebSocket 二进制数据传输</li>
</ul>
<h4 id="技术实现-1"><a href="#技术实现-1" class="headerlink" title="技术实现"></a>技术实现</h4><p><strong>1. 摄像头视频流获取</strong></p>
<p>核心代码位于 <code>src/stores/store-wave-awaken/useCameraStream.ts</code>：</p>
<pre class="line-numbers language-107:335:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-107:335:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">  /** 启动摄像头并开始录制 */
  const startCamera = async (callbacks?: CameraStreamCallbacks) => {
    try {
      // 直接使用 getUserMedia 获取摄像头视频流
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('浏览器不支持 getUserMedia API')
      }

      // 使用 ideal 而不是 exact，允许浏览器选择最接近的分辨率
      // 如果摄像头不支持 1920x1080，浏览器会自动选择最接近的支持分辨率
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 },
        },
        audio: false,
      })

      // 立即设置 mediaStream，以便预览组件可以显示
      mediaStream.value = stream

      // 获取视频轨道信息
      const videoTrack = stream.getVideoTracks()[0]
      const settings = videoTrack.getSettings()

      // 当前应用的分辨率（浏览器实际使用的分辨率）
      const appliedWidth = settings.width || 0
      const appliedHeight = settings.height || 0

      // 保存分辨率信息
      videoResolution.value = { width: appliedWidth, height: appliedHeight }

      // 检查并选择支持的视频编码格式
      const mimeType = getSupportedMimeType()
      if (!mimeType) {
        throw new Error('浏览器不支持任何视频编码格式')
      }

      // eslint-disable-next-line no-console
      console.log(`✅ 摄像头已启动: ${appliedWidth}x${appliedHeight} | 编码格式: ${mimeType}`)

      // 创建 MediaRecorder 配置
      const options: MediaRecorderOptions = {
        mimeType,
        videoBitsPerSecond: 2500000, // 2.5 Mbps
      }

      // 创建 MediaRecorder 实例
      const recorder = new MediaRecorder(stream, options)
      mediaRecorder.value = recorder

      // 初始化统计
      chunkCount.value = 0
      dataStatsStartTime.value = Date.now()
      lastChunkTime.value = null
      currentBitrate.value = 0
      totalBytesSent.value = 0
      hasFoundHeader.value = false
      headerBuffer.value = []

      // 定期更新统计信息（不打印，仅更新数据）
      statsUpdateInterval.value = window.setInterval(() => {
        if (dataStatsStartTime.value) {
          const elapsed = (Date.now() - dataStatsStartTime.value) / 1000 // 秒
          if (elapsed > 0) {
            // 计算平均比特率 (Kbps)
            const bytesPerSecond = totalBytesSent.value / elapsed
            currentBitrate.value = Math.round((bytesPerSecond * 8) / 1024) // 转换为 Kbps
          }
        }
      }, 1000) as unknown as number

      // 在缓冲区中搜索 WebM header
      // 只接受标准 WebM header: 1a 45 df a3 (0x1a45dfa3)
      // 异常 header (556f8100) 可能是编码器产生的无效数据，应该跳过并继续搜索真正的 WebM header
      const findWebMHeaderInBuffer = (buffers: Uint8Array[]): number | null => {
        // 合并所有缓冲区
        const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0)
        if (totalLength < 4) {
          return null
        }
        const merged = new Uint8Array(totalLength)
        let offset = 0
        for (const buf of buffers) {
          merged.set(buf, offset)
          offset += buf.length
        }
        // 在合并的缓冲区中搜索标准 WebM header: 1a 45 df a3
        for (let i = 0; i <= merged.length - 4; i++) {
          // 只接受标准 WebM header
          if (merged[i] === 0x1A && merged[i + 1] === 0x45 && merged[i + 2] === 0xDF && merged[i + 3] === 0xA3) {
            return i
          }
          // 如果遇到异常 header (556f8100)，跳过它继续搜索（不返回）
          // 这样可以避免将无效数据当作有效 header
        }
        return null
      }

      // 处理视频数据块
      recorder.ondataavailable = async (event) => {
        if (!event.data || event.data.size === 0) {
          return
        }

        try {
          const now = Date.now()
          const chunkSize = event.data.size

          // 将 Blob 转换为 ArrayBuffer
          const arrayBuffer = await event.data.arrayBuffer()
          const uint8Array = new Uint8Array(arrayBuffer)

          // 如果还没有找到包含 header 的数据块，累积并搜索
          if (!hasFoundHeader.value) {
            // 将当前数据块添加到缓冲区
            headerBuffer.value.push(uint8Array)

            // 如果累积的数据块数量超过限制，强制开始发送（防止无限等待）
            if (headerBuffer.value.length > MAX_HEADER_SEARCH_CHUNKS) {
              console.warn('⚠️ 已累积多个数据块但未找到 header，开始发送数据（可能 header 已被分割）')
              hasFoundHeader.value = true
            }
            else {
              // 在累积的缓冲区中搜索 header
              const headerIndex = findWebMHeaderInBuffer(headerBuffer.value)
              if (headerIndex !== null) {
                // 找到标准 WebM header，标记并准备发送
                hasFoundHeader.value = true
                console.warn(`✅ 找到标准 WebM header (1a45dfa3)（位置: ${headerIndex}），开始发送视频流数据`)

                // 如果 header 不在第一个数据块的开头，需要从 header 位置开始发送
                if (headerIndex > 0) {
                  // 合并缓冲区，从 header 位置开始
                  const totalLength = headerBuffer.value.reduce((sum, buf) => sum + buf.length, 0)
                  const merged = new Uint8Array(totalLength - headerIndex)
                  let offset = 0
                  let skipBytes = headerIndex
                  for (const buf of headerBuffer.value) {
                    if (skipBytes >= buf.length) {
                      skipBytes -= buf.length
                      continue
                    }
                    const bytesToCopy = buf.length - skipBytes
                    merged.set(buf.subarray(skipBytes), offset)
                    offset += bytesToCopy
                    skipBytes = 0
                  }
                  // 发送从 header 开始的数据
                  if (callbacks?.onChunk && merged.length > 0) {
                    callbacks.onChunk(merged.buffer)
                    chunkCount.value++
                    totalBytesSent.value += merged.length
                    lastChunkTime.value = now
                  }
                }
                else {
                  // header 在开头，发送所有累积的数据块
                  for (const buf of headerBuffer.value) {
                    if (callbacks?.onChunk) {
                      // 将 Uint8Array 转换为新的 ArrayBuffer
                      const buffer = new Uint8Array(buf).buffer
                      callbacks.onChunk(buffer)
                      chunkCount.value++
                      totalBytesSent.value += buf.length
                    }
                  }
                  lastChunkTime.value = now
                }
                // 清空缓冲区
                headerBuffer.value = []
                return
              }
              else {
                // 还没找到标准 WebM header，继续累积
                // 如果遇到异常 header (556f8100)，会被跳过，继续搜索真正的 WebM header
                console.warn(`⏳ 累积数据块 ${headerBuffer.value.length}/${MAX_HEADER_SEARCH_CHUNKS}，继续搜索标准 WebM header...`)
                return
              }
            }
          }

          // 已经找到 header，正常发送数据块
          // 如果之前累积了数据块但没找到 header（超过限制），现在发送累积的数据
          if (headerBuffer.value.length > 0) {
            for (const buf of headerBuffer.value) {
              if (callbacks?.onChunk) {
                // 将 Uint8Array 转换为新的 ArrayBuffer
                const buffer = new Uint8Array(buf).buffer
                callbacks.onChunk(buffer)
                chunkCount.value++
                totalBytesSent.value += buf.length
              }
            }
            headerBuffer.value = []
            // 注意：这里不更新 lastChunkTime，因为累积的数据块时间戳不准确
          }

          // 更新统计（当前数据块）
          chunkCount.value++
          totalBytesSent.value += chunkSize

          // 计算时间间隔
          lastChunkTime.value = now

          // 调用回调函数处理当前数据块
          if (callbacks?.onChunk) {
            callbacks.onChunk(arrayBuffer)
          }
        }
        catch (error) {
          console.error('处理视频数据块失败:', error)
          if (callbacks?.onError) {
            callbacks.onError(error instanceof Error ? error : new Error(String(error)))
          }
        }
      }

      // 处理录制错误
      recorder.onerror = (event) => {
        console.error('MediaRecorder 错误:', event)
        if (callbacks?.onError) {
          callbacks.onError(new Error('MediaRecorder 错误'))
        }
      }

      // 开始录制（每100ms获取一次数据块）
      recorder.start(100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键特性</strong>：</p>
<ul>
<li><strong>WebM Header 智能识别</strong>：实现了标准的 WebM header（0x1a45dfa3）检测机制，避免发送无效数据</li>
<li><strong>编码格式自动适配</strong>：支持 vp9、vp8、h264 等多种编码格式，自动选择浏览器支持的最佳格式</li>
<li><strong>分辨率自适应</strong>：使用 <code>ideal</code> 参数而非 <code>exact</code>，允许浏览器选择最接近的分辨率</li>
<li><strong>数据统计</strong>：实时统计比特率、帧数、数据量等信息</li>
</ul>
<p><strong>2. WebSocket 实时通信</strong></p>
<pre class="line-numbers language-114:233:apps/open-pro-client/src/stores/store-wave-awaken/store-wave-awaken.ts"><code class="language-114:233:apps/open-pro-client/src/stores/store-wave-awaken/store-wave-awaken.ts">  /** 连接挥手唤醒服务 */
  const connect = async () => {
    if (!window.__ELECTRON__)
      throw new Error('不能在非客户端环境下启动挥手唤醒服务')

    await stateChangePromise.value
    if (state.value === WebSocket.OPEN) {
      // eslint-disable-next-line no-console
      console.log('✅ 挥手唤醒服务已连接')
      return
    }

    // 从设置中获取 debug 配置
    const settingStore = useSettingStore()
    const debug = settingStore.settings['interaction:wave-awaken:debug'] ?? false

    // eslint-disable-next-line no-console
    console.log(`🔗 正在连接挥手唤醒服务: ws://${HOST}:${PORT}/ws/stream`)

    const { resolve, reject, promise } = createResolvers<WebSocket>()
    stateChangePromise.value = promise.finally(() => {
      stateChangePromise.value = null
    })

    state.value = WebSocket.CONNECTING
    const socket = new WebSocket(`ws://${HOST}:${PORT}/ws/stream?debug=${debug}`)
    const controller = new AbortController()

    socket.addEventListener('open', () => {
      window.$message?.success('挥手唤醒服务已连接')
      state.value = WebSocket.OPEN
      waveAwakenSocket.value = socket
      // 延迟一小段时间，确保服务器准备好接收数据
      // 这可以避免服务器在处理第一个数据块时出现索引越界错误
      setTimeout(() => {
        serverReady.value = true
        // eslint-disable-next-line no-console
        console.log('✅ 服务器已准备好接收视频数据')
      }, 500)
      controller.abort()
      resolve(socket)
      subjects.value.open.next(socket)
    }, {
      once: true,
      signal: controller.signal,
    })

    socket.addEventListener('close', (event) => {
      const closeInfo = {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean,
        timestamp: new Date().toISOString(),
      }

      // 根据关闭代码判断错误类型
      let errorMessage = ''
      if (event.code === 1011) {
        // 1011 表示服务器内部错误
        errorMessage = `服务器内部错误: ${event.reason || '未知错误'}`
        console.error('[挥手服务WebSocket连接异常关闭]', closeInfo)
        window.$message?.error(errorMessage)
      }
      else if (event.code === 1006) {
        // 1006 表示异常关闭（没有收到关闭帧）
        errorMessage = '连接异常断开，请检查网络连接'
        console.warn('⚠️ [挥手服务WebSocket连接异常断开]', closeInfo)
        window.$message?.warning(errorMessage)
      }
      else if (!event.wasClean && event.code !== 1000) {
        // 非正常关闭
        errorMessage = `连接关闭: ${event.reason || `错误代码 ${event.code}`}`
        console.warn('⚠️ [挥手服务WebSocket连接已关闭]', closeInfo)
        if (event.reason) {
          window.$message?.warning(errorMessage)
        }
      }
      else {
        console.warn('[🔴 挥手服务WebSocket连接已关闭]', closeInfo)
      }

      state.value = WebSocket.CLOSED
      waveAwakenSocket.value = null
      serverReady.value = false
      subjects.value.close.next(socket)
    })

    socket.addEventListener('error', (event) => {
      console.error('❌ WebSocket连接错误', {
        event,
        readyState: socket.readyState,
        timestamp: new Date().toISOString(),
      })
      reject(new Error('Connect error'))
    }, {
      once: true,
      signal: controller.signal,
    })

    socket.addEventListener('message', (ev: MessageEvent<string>) => {
      subjects.value.message.next(ev)
    })

    try {
      await promise
    }
    catch (error) {
      // 连接失败时，仍然尝试启动摄像头（保持预览功能）
      console.warn('⚠️ WebSocket连接失败，但将继续启动摄像头以显示预览')
      await startCamera().catch((err) => {
        console.error('启动摄像头失败:', err)
      })
      throw error
    }

    // 连接成功后，确保摄像头已启动
    await startCamera().catch((err) => {
      console.error('启动摄像头失败:', err)
    })
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术亮点</strong>：</p>
<ul>
<li><strong>状态管理完善</strong>：使用 <code>serverReady</code> 标志位控制数据发送时机，避免服务器未准备好时发送数据</li>
<li><strong>错误处理健壮</strong>：针对不同的 WebSocket 错误码提供详细的错误提示</li>
<li><strong>容错机制</strong>：WebSocket 连接失败时仍保持摄像头预览功能</li>
</ul>
<hr>
<h3 id="1-3-3D-模型渲染"><a href="#1-3-3D-模型渲染" class="headerlink" title="1.3 3D 模型渲染"></a>1.3 3D 模型渲染</h3><p>项目使用 Three.js 实现 3D 模型的加载、渲染和交互，支持 GLB 格式的模型文件。</p>
<pre class="line-numbers language-1:268:apps/open-pro-client/src/ui/ui-three3d/ui-three3d.vue"><code class="language-1:268:apps/open-pro-client/src/ui/ui-three3d/ui-three3d.vue"><script setup lang="ts">
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'

const props = defineProps<{
  modelUrl?: string
}>()

const containerRef = shallowRef<HTMLElement>()
const baseUrl = import.meta.env?.BASE_URL || '/'
const defaultModelUrl = `${baseUrl}3d_models/ZTZ99A.glb`
const modelUrl = computed(() => props.modelUrl ? `${baseUrl}3d_models/${props.modelUrl}` : defaultModelUrl)
console.log('【3D模型地址】', modelUrl.value)
// 场景、相机、渲染器
let scene: THREE.Scene | null = null
let camera: THREE.PerspectiveCamera | null = null
let renderer: THREE.WebGLRenderer | null = null
let controls: InstanceType<typeof OrbitControls> | null = null
let model: THREE.Group | null = null
let animationId: number | null = null

// 旋转控制参数
const rotationSpeed = ref(10) // 旋转速度（度/秒）
const rotationAngle = ref(0) // 当前旋转角度（度）
const isAnimationEnabled = ref(true) // 动画开关状态
const zoomFactor = ref(0.5) // 缩放因子
const cameraHeightFactor = ref(-0.2) // 相机高度因子（控制上下角度，值越大越俯视，值越小越仰视）
interface ModelSize {
  maxDim: number
  center: THREE.Vector3
}
const modelSize = ref<ModelSize | null>(null)

// 动画循环时间记录
let lastTime = performance.now()

// 更新相机位置
const updateCameraPosition = () => {
  if (!camera || !controls || !modelSize.value)
    return

  const distance = modelSize.value.maxDim * zoomFactor.value
  camera.position.set(distance, distance * cameraHeightFactor.value, distance)
  camera.lookAt(0, 0, 0)
  controls.target.set(0, 0, 0)
  controls.update()
}

// 加载 3D 模型
const loadModel = () => {
  if (!scene)
    return

  const loader = new GLTFLoader()

  loader.load(
    modelUrl.value,
    (gltf: { scene: THREE.Group }) => {
      if (!scene)
        return

      scene.add(gltf.scene)
      model = gltf.scene

      // 计算模型边界并调整位置
      const box = new THREE.Box3().setFromObject(gltf.scene)
      const center = box.getCenter(new THREE.Vector3())
      const size = box.getSize(new THREE.Vector3())

      // 将模型移动到场景中心
      gltf.scene.position.x = -center.x
      gltf.scene.position.y = -center.y
      gltf.scene.position.z = -center.z

      // 保存模型尺寸信息
      modelSize.value = {
        maxDim: Math.max(size.x, size.y, size.z),
        center,
      }

      // 调整相机位置以适应模型
      updateCameraPosition()
    },
    (progress: { loaded: number, total: number }) => {
      const percent = ((progress.loaded / progress.total) * 100).toFixed(2)
      // 加载进度日志
      if (percent)
        void percent
    },
    (error: Error) => {
      console.error('模型加载失败:', error)
    },
  )
}

// 动画循环
const animate = () => {
  if (!scene || !camera || !renderer)
    return

  animationId = requestAnimationFrame(animate)

  const currentTime = performance.now()
  const deltaTime = (currentTime - lastTime) / 1000 // 转换为秒
  lastTime = currentTime

  // 如果模型已加载且动画启用，让它自动360度旋转
  if (model && isAnimationEnabled.value && rotationSpeed.value > 0) {
    // 更新旋转角度（360度循环）
    rotationAngle.value += rotationSpeed.value * deltaTime
    // 保持角度在0-360度范围内
    if (rotationAngle.value >= 360) {
      rotationAngle.value -= 360
    }
    // 转换为弧度并应用旋转
    model.rotation.y = (rotationAngle.value * Math.PI) / 180
  }

  if (controls) {
    controls.update() // 更新控制器
  }
  renderer.render(scene, camera)
}

// 初始化 Three.js 场景
const initScene = () => {
  if (!containerRef.value)
    return

  // 创建场景
  scene = new THREE.Scene()
  // scene.background = new THREE.Color(0x87CEEB) // 天蓝色背景
  scene.background = null // 透明背景

  // 创建相机
  const width = containerRef.value.clientWidth
  const height = containerRef.value.clientHeight
  camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000)
  camera.position.set(2, 2, 3)

  // 创建渲染器
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
  renderer.setSize(width, height)
  renderer.shadowMap.enabled = true
  containerRef.value.appendChild(renderer.domElement)

  // 创建控制器
  controls = new OrbitControls(camera, renderer.domElement)
  controls.enableDamping = true
  controls.dampingFactor = 0.05
  // 限制上下旋转角度（可选，取消注释以启用限制）
  // controls.minPolarAngle = Math.PI / 6 // 最小角度（30度，防止旋转到模型下方）
  // controls.maxPolarAngle = Math.PI / 2 // 最大角度（90度，水平视角）

  // 添加灯光
  // 前方灯光（正Z方向）
  const lightFront = new THREE.DirectionalLight(0xFFFFFF, 0.8)
  lightFront.position.set(0, 2, 5)
  lightFront.castShadow = true
  scene.add(lightFront)

  // 后方灯光（负Z方向）
  const lightBack = new THREE.DirectionalLight(0xFFFFFF, 0.6)
  lightBack.position.set(0, 2, -5)
  lightBack.castShadow = true
  scene.add(lightBack)

  // 左侧灯光（负X方向）
  const lightLeft = new THREE.DirectionalLight(0xFFFFFF, 0.7)
  lightLeft.position.set(-5, 2, 0)
  lightLeft.castShadow = true
  scene.add(lightLeft)

  // 右侧灯光（正X方向）
  const lightRight = new THREE.DirectionalLight(0xFFFFFF, 0.7)
  lightRight.position.set(5, 2, 0)
  lightRight.castShadow = true
  scene.add(lightRight)

  // 环境光
  const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.4)
  scene.add(ambientLight)

  // 加载模型
  loadModel()

  // 开始动画循环
  animate()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术特性</strong>：</p>
<ul>
<li><strong>自动居中算法</strong>：通过计算模型边界框，自动将模型移动到场景中心</li>
<li><strong>自适应相机距离</strong>：根据模型尺寸动态调整相机位置</li>
<li><strong>四方向光源系统</strong>：前方、后方、左侧、右侧四个方向光源 + 环境光，确保模型各角度都有良好的光照</li>
<li><strong>OrbitControls 交互</strong>：支持鼠标拖拽、缩放、旋转等操作</li>
<li><strong>自动旋转动画</strong>：支持可配置的自动旋转速度和开关</li>
</ul>
<hr>
<h2 id="二、技术难点与解决方案"><a href="#二、技术难点与解决方案" class="headerlink" title="二、技术难点与解决方案"></a>二、技术难点与解决方案</h2><h3 id="2-1-摄像头视频数据获取的踩坑经验"><a href="#2-1-摄像头视频数据获取的踩坑经验" class="headerlink" title="2.1 摄像头视频数据获取的踩坑经验"></a>2.1 摄像头视频数据获取的踩坑经验</h3><h4 id="问题一：WebM-Header-识别问题"><a href="#问题一：WebM-Header-识别问题" class="headerlink" title="问题一：WebM Header 识别问题"></a>问题一：WebM Header 识别问题</h4><p><strong>问题描述</strong>：<br>MediaRecorder 在某些浏览器中产生的第一个数据块可能不包含完整的 WebM header，或者包含异常 header（如 0x556f8100），导致服务器无法正确解析视频流。</p>
<p><strong>解决方案</strong>：<br>实现了一个智能的 header 搜索机制：</p>
<ol>
<li><strong>累积缓冲策略</strong>：在找到有效 header 之前，累积前 N 个数据块</li>
<li><strong>标准 Header 检测</strong>：只接受标准的 WebM header（0x1a45dfa3），跳过异常数据</li>
<li><strong>超时保护</strong>：如果累积超过 5 个数据块仍未找到 header，强制开始发送（避免无限等待）</li>
<li><strong>数据对齐</strong>：如果 header 不在第一个数据块开头，从 header 位置开始发送，确保数据完整性</li>
</ol>
<pre class="line-numbers language-183:286:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-183:286:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">      // 在缓冲区中搜索 WebM header
      // 只接受标准 WebM header: 1a 45 df a3 (0x1a45dfa3)
      // 异常 header (556f8100) 可能是编码器产生的无效数据，应该跳过并继续搜索真正的 WebM header
      const findWebMHeaderInBuffer = (buffers: Uint8Array[]): number | null => {
        // 合并所有缓冲区
        const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0)
        if (totalLength < 4) {
          return null
        }
        const merged = new Uint8Array(totalLength)
        let offset = 0
        for (const buf of buffers) {
          merged.set(buf, offset)
          offset += buf.length
        }
        // 在合并的缓冲区中搜索标准 WebM header: 1a 45 df a3
        for (let i = 0; i <= merged.length - 4; i++) {
          // 只接受标准 WebM header
          if (merged[i] === 0x1A && merged[i + 1] === 0x45 && merged[i + 2] === 0xDF && merged[i + 3] === 0xA3) {
            return i
          }
          // 如果遇到异常 header (556f8100)，跳过它继续搜索（不返回）
          // 这样可以避免将无效数据当作有效 header
        }
        return null
      }

      // 处理视频数据块
      recorder.ondataavailable = async (event) => {
        if (!event.data || event.data.size === 0) {
          return
        }

        try {
          const now = Date.now()
          const chunkSize = event.data.size

          // 将 Blob 转换为 ArrayBuffer
          const arrayBuffer = await event.data.arrayBuffer()
          const uint8Array = new Uint8Array(arrayBuffer)

          // 如果还没有找到包含 header 的数据块，累积并搜索
          if (!hasFoundHeader.value) {
            // 将当前数据块添加到缓冲区
            headerBuffer.value.push(uint8Array)

            // 如果累积的数据块数量超过限制，强制开始发送（防止无限等待）
            if (headerBuffer.value.length > MAX_HEADER_SEARCH_CHUNKS) {
              console.warn('⚠️ 已累积多个数据块但未找到 header，开始发送数据（可能 header 已被分割）')
              hasFoundHeader.value = true
            }
            else {
              // 在累积的缓冲区中搜索 header
              const headerIndex = findWebMHeaderInBuffer(headerBuffer.value)
              if (headerIndex !== null) {
                // 找到标准 WebM header，标记并准备发送
                hasFoundHeader.value = true
                console.warn(`✅ 找到标准 WebM header (1a45dfa3)（位置: ${headerIndex}），开始发送视频流数据`)

                // 如果 header 不在第一个数据块的开头，需要从 header 位置开始发送
                if (headerIndex > 0) {
                  // 合并缓冲区，从 header 位置开始
                  const totalLength = headerBuffer.value.reduce((sum, buf) => sum + buf.length, 0)
                  const merged = new Uint8Array(totalLength - headerIndex)
                  let offset = 0
                  let skipBytes = headerIndex
                  for (const buf of headerBuffer.value) {
                    if (skipBytes >= buf.length) {
                      skipBytes -= buf.length
                      continue
                    }
                    const bytesToCopy = buf.length - skipBytes
                    merged.set(buf.subarray(skipBytes), offset)
                    offset += bytesToCopy
                    skipBytes = 0
                  }
                  // 发送从 header 开始的数据
                  if (callbacks?.onChunk && merged.length > 0) {
                    callbacks.onChunk(merged.buffer)
                    chunkCount.value++
                    totalBytesSent.value += merged.length
                    lastChunkTime.value = now
                  }
                }
                else {
                  // header 在开头，发送所有累积的数据块
                  for (const buf of headerBuffer.value) {
                    if (callbacks?.onChunk) {
                      // 将 Uint8Array 转换为新的 ArrayBuffer
                      const buffer = new Uint8Array(buf).buffer
                      callbacks.onChunk(buffer)
                      chunkCount.value++
                      totalBytesSent.value += buf.length
                    }
                  }
                  lastChunkTime.value = now
                }
                // 清空缓冲区
                headerBuffer.value = []
                return
              }
              else {
                // 还没找到标准 WebM header，继续累积
                // 如果遇到异常 header (556f8100)，会被跳过，继续搜索真正的 WebM header
                console.warn(`⏳ 累积数据块 ${headerBuffer.value.length}/${MAX_HEADER_SEARCH_CHUNKS}，继续搜索标准 WebM header...`)
                return
              }
            }
          }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="问题二：编码格式兼容性"><a href="#问题二：编码格式兼容性" class="headerlink" title="问题二：编码格式兼容性"></a>问题二：编码格式兼容性</h4><p><strong>问题描述</strong>：<br>不同浏览器对视频编码格式的支持差异较大，Chrome 支持 vp9/vp8，而某些浏览器可能只支持 h264 或 mp4。</p>
<p><strong>解决方案</strong>：<br>实现编码格式自动检测和降级策略：</p>
<pre class="line-numbers language-44:60:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-44:60:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">  /** 检查浏览器支持的视频编码格式 */
  const getSupportedMimeType = (): string | null => {
    const types = [
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm;codecs=h264',
      'video/webm',
      'video/mp4',
    ]

    for (const type of types) {
      if (MediaRecorder.isTypeSupported(type)) {
        return type
      }
    }
    return null
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优先级策略</strong>：</p>
<ol>
<li>vp9（最佳压缩率）</li>
<li>vp8（较好压缩率）</li>
<li>h264（广泛兼容）</li>
<li>webm（无 codec 指定，浏览器自动选择）</li>
<li>mp4（最后备选）</li>
</ol>
<h4 id="问题三：分辨率适配"><a href="#问题三：分辨率适配" class="headerlink" title="问题三：分辨率适配"></a>问题三：分辨率适配</h4><p><strong>问题描述</strong>：<br>不同摄像头的支持分辨率不同，如果强制指定 <code>exact</code> 分辨率，可能导致获取失败。</p>
<p><strong>解决方案</strong>：<br>使用 <code>ideal</code> 参数而非 <code>exact</code>，允许浏览器选择最接近的支持分辨率：</p>
<pre class="line-numbers language-117:124:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-117:124:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30 },
        },
        audio: false,
      })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>自动适配硬件能力</li>
<li>避免因分辨率不匹配导致的获取失败</li>
<li>可通过 <code>getSettings()</code> 获取实际应用的分辨率</li>
</ul>
<h4 id="问题四：摄像头权限与错误处理"><a href="#问题四：摄像头权限与错误处理" class="headerlink" title="问题四：摄像头权限与错误处理"></a>问题四：摄像头权限与错误处理</h4><p><strong>问题描述</strong>：<br>不同操作系统和浏览器对摄像头权限的处理方式不同，错误信息不够友好。</p>
<p><strong>解决方案</strong>：<br>实现详细的错误分类和用户友好的提示：</p>
<pre class="line-numbers language-337:368:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts"><code class="language-337:368:apps/open-pro-client/src/stores/store-wave-awaken/useCameraStream.ts">    catch (error) {
      console.error('❌ 启动摄像头失败:', error)
      if (error instanceof Error) {
        // 记录详细的错误信息
        const errorDetails = {
          name: error.name,
          message: error.message,
          stack: error.stack,
        }
        console.error('错误详情:', errorDetails)

        // 如果是 "Could not start video source" 错误，提供更详细的错误信息
        if (error.message.includes('Could not start video source')) {
          const enhancedError = new Error(
            `Could not start video source: 摄像头可能被其他应用占用、权限未授予或硬件故障。原始错误: ${error.message}`,
          )
          enhancedError.name = error.name
          if (callbacks?.onError) {
            callbacks.onError(enhancedError)
          }
          stopCamera()
          throw enhancedError
        }

        if (callbacks?.onError) {
          callbacks.onError(error)
        }
      }
      // 清理资源
      stopCamera()
      throw error
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Electron 主进程中也处理了 macOS 的权限请求：</p>
<pre class="line-numbers language-44:58:apps/open-pro-client/electron/main/index.ts"><code class="language-44:58:apps/open-pro-client/electron/main/index.ts">  app.whenReady().then(async () => {
    // 在 macOS 上主动请求摄像头权限
    if (process.platform === 'darwin') {
      try {
        const cameraStatus = systemPreferences.getMediaAccessStatus('camera')
        if (cameraStatus !== 'granted') {
          const isAuthorized = await systemPreferences.askForMediaAccess('camera')
          if (!isAuthorized) {
            console.warn('⚠️ 摄像头权限未授予，请在系统设置中授予权限')
          }
        }
      }
      catch (error) {
        console.error('请求摄像头权限失败:', error)
      }
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="2-2-复杂状态机的设计与管理"><a href="#2-2-复杂状态机的设计与管理" class="headerlink" title="2.2 复杂状态机的设计与管理"></a>2.2 复杂状态机的设计与管理</h3><h4 id="状态机架构"><a href="#状态机架构" class="headerlink" title="状态机架构"></a>状态机架构</h4><p>项目采用了基于 RxJS 的响应式状态机，管理数字人交互的完整生命周期。状态包括：</p>
<ul>
<li><code>none</code>: 初始状态</li>
<li><code>standby</code>: 待机状态</li>
<li><code>focus</code>: 聚焦状态（人脸进入时）</li>
<li><code>awaken</code>: 唤醒状态（语音/挥手唤醒）</li>
<li><code>listen</code>: 监听状态（等待语音输入）</li>
<li><code>transition</code>: 过渡状态</li>
<li><code>speech</code>: 发言状态（数字人正在说话）</li>
<li><code>exit</code>: 退出状态</li>
<li><code>idle</code>: 空闲状态</li>
</ul>
<h4 id="状态锁机制"><a href="#状态锁机制" class="headerlink" title="状态锁机制"></a>状态锁机制</h4><p>为了防止状态竞争和确保状态转换的原子性，实现了 <code>StageLock</code> 机制：</p>
<pre class="line-numbers language-9:120:apps/open-pro-client/src/stores/store-state/store-state.ts"><code class="language-9:120:apps/open-pro-client/src/stores/store-state/store-state.ts">/** 生命周期锁 */
interface StageLock {
  /** 锁 id，用于内部状态管理 */
  id: string
  /** 锁所属的周期名称 */
  name: App.StageName
  /** 锁的取消信号 */
  signal: AbortSignal
  /** 锁释放/取消时兑现的 promise, 成功兑现时返回释放原因 */
  finished: Promise<string | Error>
  /** 取消此锁 */
  abort: <T>(reason: T) => void
  /** 返回此锁是否已经被释放 */
  isReleased: () => boolean
  /**
   * 释放此锁，返回释放是否成功的标志，如果释放失败，表示此锁已被释放或取消
   * @param {string} type 参数用于调试
   */
  release: (type?: string) => boolean
  /**
   * 在触发清理方法时调用
   */
  onDispose: (callback: () => void) => {
    off: () => void
  }
  /**
   * 在离开作用域时自动清理锁
   * @note 在被闭包持有时会失效，请慎重处理闭包情况！
   */
  [Symbol.dispose]: () => void
}

const createId = () => {
  return [...
(num => num.toString(16).padStart(2, '0'))
    .join('')


export const useStateStore = defineStore('state', () => {
  const devStore = useDevStore()
  const userStore = useUserStore()

  const subjects = shallowRef({
    stage: new Subject<App.Stage>(),
    /** 数字人生命周期改变时 */
    stageChange: new Subject<App.StageName>(),
    /** 每次触发【交互】时（此行为流用于重置回到待机状态的定时器） */
    interaction: new Subject<void>(),
  } as const)

  /** 当前生命周期 */
  const currentStage = ref<App.StageName>('none')

  /** 生命周期原子锁 */



  /** 获取生命周期锁 */
  const getStageLock = (name: App.StageName): StageLock | undefined => {
    if (stageLock.value)
      return
    const lockId = createId()
    const controller = new AbortController()

    const { resolve, promise } = createResolvers<string | Error>()
    const lock: StageLock = {
      id: lockId,
      name,
      signal: controller.signal,
      finished: promise,
      abort: (reason) => {
        if (controller.signal.aborted)
          return
        devStore.log.info('stage', 'abort', reason, name)
        controller.abort(reason)
        stageLock.value = null
        try {
          controller.signal.throwIfAborted()
        }
        catch (err) {
          resolve(err instanceof Error ? err : new Error(JSON.stringify(err)))
        }
        disposeHook.trigger()
        console.groupEnd()
      },
      isReleased: () => {
        return controller.signal.aborted || (lockId !== stageLock.value?.id)
      },
      release: (type = 'release') => {
        if (lockId !== stageLock.value?.id)
          return false
        stageLock.value = null
        resolve(type)
        devStore.log.info('stage', type, name)
        console.groupEnd()
        return true
      },
      onDispose: disposeHook.on,
      [Symbol.dispose]: () => {
        try {
          disposeHook.trigger()
          lock.release('dispose')
        }
        catch {
          // 忽略
        }
      },
    }
    stageLock.value = lock
    console.group(`stage: "${name}"`)
    devStore.log.info('stage', 'getLock', name)
    return lock
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="状态打断机制"><a href="#状态打断机制" class="headerlink" title="状态打断机制"></a>状态打断机制</h4><p>支持在任意状态通过 <code>abort</code> 方法打断当前状态，并触发状态转换：</p>
<pre class="line-numbers language-235:244:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue"><code class="language-235:244:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue">// 语音唤醒可以跳过 [focus]，直接进入 [awaken] 状态
// FIXME: 需要打断发言的唤醒流依然存在问题，待优化
useSubscription(awakenStore.subjects.awake.subscribe(async (data) => {
  // 已处于 [awaken] 状态时不能递归进入
  if (stateStore.stageLock?.name === 'awaken') {
    devStore.log.info('语音唤醒', '不能递归唤醒', data)
    return
  }
  devStore.log.info('语音唤醒', data)
  stateStore.stageLock?.abort(STAGE_REASON.AWAKEN)
  stateStore.subjects.stage.next({ name: 'awaken' })
}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>技术亮点</strong>：</p>
<ul>
<li><strong>原子性保证</strong>：通过锁机制确保状态转换的原子性</li>
<li><strong>可中断性</strong>：支持异步操作的打断（基于 AbortController）</li>
<li><strong>资源清理</strong>：状态切换时自动清理资源（通过 <code>onDispose</code> 钩子）</li>
<li><strong>调试友好</strong>：提供详细的状态转换日志</li>
</ul>
<hr>
<h3 id="2-3-异步操作的时序管理"><a href="#2-3-异步操作的时序管理" class="headerlink" title="2.3 异步操作的时序管理"></a>2.3 异步操作的时序管理</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>一个完整的交互流程涉及多个异步环节：</p>
<ol>
<li>人脸识别（异步）</li>
<li>语音唤醒（异步）</li>
<li>语音识别（异步）</li>
<li>数字人驱动（异步）</li>
<li>流式对话（异步）</li>
</ol>
<p>这些环节可能相互打断，需要谨慎处理时序。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 RxJS 的 <code>switchMap</code>、<code>takeUntil</code>、<code>race</code> 等操作符管理异步流程：</p>
<pre class="line-numbers language-338:359:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue"><code class="language-338:359:apps/open-pro-client/src/pages/home/components/interaction/interaction-mode-soft.vue">// ### 3. 进入到 [awaken] 状态
// - 进行 [唤醒响应] 动作，动作结束后进入 [listen] 状态
useSubscription(awaken$.subscribe(async () => {
  try {
    const lock = stateStore.getStageLock('awaken')
    if (!lock)
      return

    if (wakeupGuideText.value) {
      if (ttsaStore.voiceState !== 'idle')
        await ttsaStore.interrupt()
      await ttsaStore.speak(wakeupGuideText.value)
    }

    if (!lock.release())
      return
    stateStore.subjects.stage.next({ name: 'listen' })
  }
  catch (err) {
    switchStageByReason(err)
  }
}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关键技巧</strong>：</p>
<ol>
<li><strong>使用 <code>takeUntil</code> 实现可中断</strong>：当状态被 <code>abort</code> 时，自动取消未完成的异步操作</li>
<li><strong>使用 <code>race</code> 实现超时</strong>：多个异步操作竞争，最先完成的触发后续流程</li>
<li><strong>使用 <code>switchMap</code> 取消前一个</strong>：状态切换时自动取消前一个状态的异步操作</li>
</ol>
<hr>
<h2 id="三、技术经验总结"><a href="#三、技术经验总结" class="headerlink" title="三、技术经验总结"></a>三、技术经验总结</h2><h3 id="3-1-响应式编程的最佳实践"><a href="#3-1-响应式编程的最佳实践" class="headerlink" title="3.1 响应式编程的最佳实践"></a>3.1 响应式编程的最佳实践</h3><h4 id="RxJS-在项目中的应用"><a href="#RxJS-在项目中的应用" class="headerlink" title="RxJS 在项目中的应用"></a>RxJS 在项目中的应用</h4><p>项目大量使用 RxJS 管理异步事件流，主要应用场景：</p>
<ol>
<li><strong>状态流管理</strong>：通过 <code>Subject</code> 管理状态变更</li>
<li><strong>事件订阅</strong>：使用 <code>subscribe</code> 响应状态变化</li>
<li><strong>操作符组合</strong>：使用 <code>switchMap</code>、<code>filter</code>、<code>takeUntil</code> 等操作符处理复杂流程</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>代码清晰，逻辑链式表达</li>
<li>自动处理取消和清理</li>
<li>易于测试和调试</li>
</ul>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 挥手唤醒检测流程</span>
subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>message
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
    <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 解析 JSON 响应</span>
      <span class="token keyword">const</span> response <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> as WaveAwakenResponse<span class="token punctuation">;</span>
      <span class="token keyword">return</span> response<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">filter</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">:</span> response is WaveAwakenResultResponse <span class="token operator">=</span><span class="token operator">></span>
        response <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        response<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"result"</span> <span class="token operator">&amp;&amp;</span>
        response<span class="token punctuation">.</span>waving <span class="token operator">===</span> <span class="token keyword">true</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 触发唤醒事件</span>
    subjects<span class="token punctuation">.</span>value<span class="token punctuation">.</span>awake<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-2-Electron-应用开发经验"><a href="#3-2-Electron-应用开发经验" class="headerlink" title="3.2 Electron 应用开发经验"></a>3.2 Electron 应用开发经验</h3><h4 id="主进程与渲染进程通信"><a href="#主进程与渲染进程通信" class="headerlink" title="主进程与渲染进程通信"></a>主进程与渲染进程通信</h4><p>项目使用 Electron 的 IPC 通信机制，通过 preload 脚本暴露安全的 API：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// preload/index.ts</span>
contextBridge<span class="token punctuation">.</span><span class="token function">exposeInMainWorld</span><span class="token punctuation">(</span><span class="token string">"__ELECTRON__"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">"awaken:launch"</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> ipcRenderer<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">"awaken:launch"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>在 Electron 中，需要主动请求系统权限（特别是 macOS）：</p>
<pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 在 app.whenReady() 时请求摄像头权限</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">===</span> <span class="token string">"darwin"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cameraStatus <span class="token operator">=</span> systemPreferences<span class="token punctuation">.</span><span class="token function">getMediaAccessStatus</span><span class="token punctuation">(</span><span class="token string">"camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cameraStatus <span class="token operator">!==</span> <span class="token string">"granted"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    await systemPreferences<span class="token punctuation">.</span><span class="token function">askForMediaAccess</span><span class="token punctuation">(</span><span class="token string">"camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-3-性能优化策略"><a href="#3-3-性能优化策略" class="headerlink" title="3.3 性能优化策略"></a>3.3 性能优化策略</h3><h4 id="1-视频流优化"><a href="#1-视频流优化" class="headerlink" title="1. 视频流优化"></a>1. 视频流优化</h4><ul>
<li><strong>数据块大小控制</strong>：通过 <code>recorder.start(100)</code> 控制每 100ms 获取一次数据块</li>
<li><strong>比特率限制</strong>：设置 <code>videoBitsPerSecond: 2500000</code> (2.5 Mbps) 控制带宽</li>
<li><strong>编码格式选择</strong>：优先选择压缩率高的格式（vp9 &gt; vp8 &gt; h264）</li>
</ul>
<h4 id="2-3D-渲染优化"><a href="#2-3D-渲染优化" class="headerlink" title="2. 3D 渲染优化"></a>2. 3D 渲染优化</h4><ul>
<li><strong>按需渲染</strong>：只在模型可见时进行渲染</li>
<li><strong>资源清理</strong>：组件卸载时正确释放 Three.js 资源</li>
<li><strong>光照优化</strong>：使用环境光 + 方向光的组合，减少计算量</li>
</ul>
<h4 id="3-状态管理优化"><a href="#3-状态管理优化" class="headerlink" title="3. 状态管理优化"></a>3. 状态管理优化</h4><ul>
<li><strong>响应式更新</strong>：使用 <code>computed</code> 和 <code>watchEffect</code> 实现细粒度的响应式更新</li>
<li><strong>避免不必要的订阅</strong>：使用 <code>takeUntil</code> 及时取消订阅</li>
</ul>
<hr>
<h2 id="四、项目架构总结"><a href="#四、项目架构总结" class="headerlink" title="四、项目架构总结"></a>四、项目架构总结</h2><h3 id="4-1-目录结构"><a href="#4-1-目录结构" class="headerlink" title="4.1 目录结构"></a>4.1 目录结构</h3><pre><code>apps/open-pro-client/
├── electron/              # Electron 主进程代码
│   ├── main/             # 主线程
│   └── preload/          # 预加载脚本
├── src/
│   ├── apis/             # 后端接口
│   ├── core/             # 核心功能模块
│   │   ├── interaction-composite/    # 交互逻辑
│   │   ├── speech-recognizer/        # 语音识别引擎
│   │   └── ttsa-renderer/            # 数字人渲染器
│   ├── stores/           # 状态管理
│   │   ├── store-ttsa/               # 数字人状态
│   │   ├── store-wave-awaken/        # 挥手唤醒状态
│   │   ├── store-awaken/             # 语音唤醒状态
│   │   ├── store-asr/                # 语音识别状态
│   │   └── store-state/              # 应用状态机
│   ├── pages/            # 页面组件
│   └── ui/               # UI 组件
│       ├── ui-three3d/               # 3D 模型组件
│       └── ui-camera-preview/        # 摄像头预览组件
└── public/               # 静态资源
    ├── server/           # 本地服务（挥手唤醒服务等）
    └── weights/          # AI 模型文件</code></pre><h3 id="4-2-核心设计模式"><a href="#4-2-核心设计模式" class="headerlink" title="4.2 核心设计模式"></a>4.2 核心设计模式</h3><ol>
<li><strong>适配器模式</strong>：语音识别引擎适配层，统一不同服务商的接口</li>
<li><strong>观察者模式</strong>：使用 RxJS Subject 实现事件订阅</li>
<li><strong>状态机模式</strong>：通过 StageLock 管理复杂的状态流转</li>
<li><strong>组合模式</strong>：将多个功能模块组合成完整的交互流程</li>
</ol>
<hr>
<h2 id="五、总结与展望"><a href="#五、总结与展望" class="headerlink" title="五、总结与展望"></a>五、总结与展望</h2><h3 id="5-1-项目亮点"><a href="#5-1-项目亮点" class="headerlink" title="5.1 项目亮点"></a>5.1 项目亮点</h3><ol>
<li><strong>多模态交互</strong>：集成语音、手势、人脸识别等多种交互方式</li>
<li><strong>实时性保证</strong>：WebSocket 实时通信，低延迟的视频流传输</li>
<li><strong>健壮性设计</strong>：完善的错误处理、状态管理、资源清理机制</li>
<li><strong>可扩展架构</strong>：模块化设计，易于扩展新功能</li>
</ol>
<h3 id="5-2-技术难点攻克"><a href="#5-2-技术难点攻克" class="headerlink" title="5.2 技术难点攻克"></a>5.2 技术难点攻克</h3><ol>
<li><strong>WebM Header 识别</strong>：解决了 MediaRecorder 数据不完整的问题</li>
<li><strong>编码格式兼容</strong>：实现了跨浏览器的编码格式自动适配</li>
<li><strong>复杂状态管理</strong>：通过状态锁机制解决了异步操作的时序问题</li>
<li><strong>性能优化</strong>：通过多种优化策略保证了应用的流畅性</li>
</ol>
<h3 id="5-3-未来优化方向"><a href="#5-3-未来优化方向" class="headerlink" title="5.3 未来优化方向"></a>5.3 未来优化方向</h3><ol>
<li><strong>性能进一步提升</strong>：考虑使用 WebAssembly 加速视频处理</li>
<li><strong>错误恢复机制</strong>：增强网络异常、服务异常的自动恢复能力</li>
<li><strong>用户体验优化</strong>：增加更多的交互反馈和动画效果</li>
<li><strong>测试覆盖</strong>：增加单元测试和集成测试的覆盖率</li>
</ol>
<hr>
<h2 id="附录：关键代码文件索引"><a href="#附录：关键代码文件索引" class="headerlink" title="附录：关键代码文件索引"></a>附录：关键代码文件索引</h2><ul>
<li><strong>摄像头视频流管理</strong>: <code>src/stores/store-wave-awaken/useCameraStream.ts</code></li>
<li><strong>挥手唤醒服务</strong>: <code>src/stores/store-wave-awaken/store-wave-awaken.ts</code></li>
<li><strong>数字人渲染器</strong>: <code>src/core/ttsa-renderer/ttsa-renderer.vue</code></li>
<li><strong>3D 模型组件</strong>: <code>src/ui/ui-three3d/ui-three3d.vue</code></li>
<li><strong>状态机管理</strong>: <code>src/stores/store-state/store-state.ts</code></li>
<li><strong>交互逻辑</strong>: <code>src/pages/home/components/interaction/interaction-mode-soft-hardware.vue</code></li>
<li><strong>Electron 主进程</strong>: <code>electron/main/index.ts</code></li>
</ul>
<hr>
<p><em>本文档基于项目实际代码总结，记录了开发过程中的技术难点、解决方案和经验总结，希望对后续开发和类似项目有所借鉴。</em></p>
<hr>
<p><em>最后更新：2025-12-17</em></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </code></pre></div><hr><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.88rem}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fa fa-close"></i></a><h4 class="reward-title">你的赏识是我前进的动力!</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/reward/alipay.bmp" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/reward/wechat.bmp" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div></div><script defer src="/libs/share/js/social-share.min.js"></script><div class="reprint1"><p><span class="reprint1-tip"><i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明: </span><a href="https://qindongxu-cn.github.io" class="b-link-green">秦东旭的博客</a> <i class="fa fa-angle-right fa-lg fa-fw text-color"></i> <a href="/2025/12/17/you-ling-pro-jun-gong-ding-zhi-hua-shu-zi-ren-da-ping-xiang-mu-ji-zhu-zong-jie/" class="b-link-green">有灵Pro：军工定制化数字人大屏项目技术总结</a></p></div></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div id="gitalk-container" class="card-content"></div></div><script defer src="/libs/gitalk/gitalk.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.Gitalk&&new Gitalk({clientID:"XXXXXXXXXXXXXXXXXXXXXXXXXXXX",clientSecret:"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",repo:"shw2018.github.io",owner:"shw2018",admin:["shw2018"],id:"2025/12/17/you-ling-pro-jun-gong-ding-zhi-hua-shu-zi-ren-da-ping-xiang-mu-ji-zhu-zong-jie/",distractionFreeMode:!1}).render("gitalk-container")})</script><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url("") 100% 100% no-repeat}#vcomments input[type=email],#vcomments input[type=text],#vcomments input[type=url],#vcomments textarea{box-sizing:border-box}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#42b983;font-weight:500;text-decoration:underline}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}.v .vlist .vcard{padding-top:2.5em!important}</style><div class="card valine-card" data-aos="fade-up"><div id="vcomments" class="card-content"></div></div><script defer src="/libs/valine/av-min.js"></script><script defer src="/libs/valine/Valine.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.Valine&&new Valine({el:"#vcomments",appId:"XXXXXXXXXXXXXXXXXXXXXXXX",appKey:"XXXXXXXXXXXXXXXXXXXXXX",notify:!0,verify:!0,visitor:!0,avatar:"mm",pageSize:"10",lang:"zh-cn",placeholder:"just go go"})})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fa fa-dot-circle-o"></i>&nbsp;本篇</div><div class="card"><a href="/2025/12/17/you-ling-pro-jun-gong-ding-zhi-hua-shu-zi-ren-da-ping-xiang-mu-ji-zhu-zong-jie/"><div class="card-image"><img src="/medias/featureimages/8.jpg" class="responsive-img" alt="有灵Pro：军工定制化数字人大屏项目技术总结"> <span class="card-title">有灵Pro：军工定制化数字人大屏项目技术总结</span></div></a><div class="card-content article-content"><div class="summary block-with-text">基于 Electron + Vue 3 + TypeScript 打造的军工定制化数字人大屏项目，集成数字人渲染、挥手唤醒、语音识别、人脸识别和 3D 模型展示等多模态交互能力的完整技术实践总结。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2025-12-17 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-category" target="_blank">项目总结</a></span></div></div><div class="card-action article-tags"><a href="/tags/Vue3/" target="_blank"><span class="chip bg-color">Vue3</span> </a><a href="/tags/Electron/" target="_blank"><span class="chip bg-color">Electron</span> </a><a href="/tags/Three-js/" target="_blank"><span class="chip bg-color">Three.js</span> </a><a href="/tags/%E6%95%B0%E5%AD%97%E4%BA%BA/" target="_blank"><span class="chip bg-color">数字人</span> </a><a href="/tags/%E5%86%9B%E5%B7%A5%E9%A1%B9%E7%9B%AE/" target="_blank"><span class="chip bg-color">军工项目</span> </a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" target="_blank"><span class="chip bg-color">技术总结</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fa fa-chevron-right"></i></div><div class="card"><a href="/2025/12/09/you-yan-xiang-mu-shou-xi/"><div class="card-image"><img src="/medias/featureimages/1.jpg" class="responsive-img" alt="有言项目熟悉"> <span class="card-title">有言项目熟悉</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Youyan Multi 项目技术手册，包含项目概览、技术栈、架构设计、开发环境配置、代码规范、核心模块说明、开发流程、常见问题和部署说明。</div><div class="publish-info"><span class="publish-date"><i class="fa fa-clock-o fa-fw icon-date"></i>2025-12-09 </span><span class="publish-author"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/" class="post-category" target="_blank">项目文档</a></span></div></div><div class="card-action article-tags"><a href="/tags/Vue3/" target="_blank"><span class="chip bg-color">Vue3</span> </a><a href="/tags/Monorepo/" target="_blank"><span class="chip bg-color">Monorepo</span> </a><a href="/tags/%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/" target="_blank"><span class="chip bg-color">项目文档</span> </a><a href="/tags/Nuxt3/" target="_blank"><span class="chip bg-color">Nuxt3</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0===window.getSelection||(""+(n=window.getSelection())).length<Number.parseInt("120")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"===n.getRangeAt(0).commonAncestorContainer.nodeName&&(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: 秦东旭的博客<br />作者: 秦东旭<br />链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200))})</script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fa fa-list"></i></a></div><script defer src="/libs/tocbot/tocbot.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){if(void 0!==window.tocbot){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),headingSelector:"h1, h2, h3, h4, h5"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h1, h2, h3, h4, h5").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget"),i=($(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")}),"expanded"),c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).slideUp(500),a.removeClass("l9")):(c.addClass(i).slideDown(500),a.addClass("l9"));var e="artDetail",n="prenext-posts";if(0!==(e=$("#"+e)).length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+n).width(t)}})}})</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right">Copyright&copy; 2021 秦东旭. <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">滇ICP备2021008757号-1</a><br><span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span><br><span id="busuanzi_container_site_pv" style="display:none"></span> 总访问量: <span id="busuanzi_value_site_pv" class="white-color"></span> <span id="busuanzi_container_site_uv" style="display:none"></span> 人次&nbsp; | &nbsp;访客人数: <span id="busuanzi_value_site_uv" class="white-color"></span> 人 &nbsp; | &nbsp;字数统计:&nbsp; <span class="white-color">234.5k</span> 字<br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/shw2018" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i> </a><a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=qindongxu1203@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i> </a><a href="https://zhihu.com/people/小当家" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50"><i class="fa fa-inverse">知</i> </a><a href="http://wpa.qq.com/msgrd?v=3&uin=1639758371&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50"><i class="fa fa-qq"></i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><script language="javascript">function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2021, 08, 10, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已勉强运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();</script><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script defer src="/js/search.js"></script><script type="text/javascript">document.addEventListener("DOMContentLoaded",function(){"function"==typeof window.searchFunc&&searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script defer src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/masonry/4.2.2/masonry.pkgd.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/aos/3.0.0-beta.6/aos.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/scrollprogress/3.0.2/scrollProgress.min.js" crossorigin="anonymous"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" crossorigin="anonymous"></script><script defer src="/js/matery.js"></script><script>window.__hexoLoadScript=function(t,e){var r,n;return t?(r=e||{},(n=document.createElement("script")).src=t,r.async&&(n.async=!0),!1!==r.defer&&(n.defer=!0),r.crossorigin&&(n.crossOrigin=r.crossorigin),r.attrs&&Object.keys(r.attrs).forEach(function(t){n.setAttribute(t,r.attrs[t])}),r.onLoad&&n.addEventListener("load",r.onLoad,{once:!0}),(r.target||document.body).appendChild(n),n):null}</script><script defer src="/libs/others/clicklove.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="看不见我🙈~看不见我🙈~",clearTimeout(st)):(document.title="(๑•̀ㅂ•́) ✧被发现了～",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><script type="text/javascript">(()=>{var e;window.innerWidth<=768||(e=function(){window.__hexoLoadScript("/js/sakura.js")},"complete"===document.readyState?e():window.addEventListener("load",e,{once:!0}))})()</script><script defer src="/js/wenzi.js" type="text/javascript"></script><script>(()=>{function e(){window.__hexoLoadScript("//code.tidio.co/xxxxxxxxxxxxxxxxxxxxxxxxxxx.js",{async:!0,defer:!1,crossorigin:"anonymous",onLoad:function(){var t=function(){if(void 0===window.jQuery)return window.setTimeout(t,100);function e(){var e,t,o,n=d("#tidio-chat iframe");n.length&&(o=(o=document.getElementById("tidio-chat-iframe"))||document.querySelector("#tidio-chat iframe"))&&"block"===n.css("display")&&(977<(e=window.innerWidth)?(o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-40px":document.querySelector("div.toc-title")&&977<e?"80px":"20px",o.style.right="-15px",t=parseInt(n.css("height"),10),o.style.height=520<=t?"520px":n.css("height"),o.style.zIndex="997"):601<e&&e<992?(o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-40px":"20px",o.style.right="-15px",o.style.zIndex="997"):e<=601&&(t=parseInt(n.css("height"),10),o.style.bottom=document.querySelector("div#backTop.top-scroll")&&"none"===getComputedStyle(document.querySelector("div#backTop.top-scroll")).display?"-10px":"45px",o.style.zIndex=230<=t?"998":"997"))}var d=window.jQuery;e(),window.addEventListener("resize",e),window.setInterval(e,200)};t()}})}"complete"===document.readyState?e():window.addEventListener("load",e,{once:!0})})()</script><script type="text/javascript">(()=>{var n;window.innerWidth<=992||(n=function(){window.__hexoLoadScript("/libs/background/ribbon.min.js",{attrs:{size:"150",alpha:"0.6",zIndex:"-1"}})},"complete"===document.readyState?n():window.addEventListener("load",n,{once:!0}))})()</script><script type="text/javascript">(()=>{var n;window.innerWidth<=992||(n=function(){window.__hexoLoadScript("/libs/background/ribbon-dynamic.js")},"complete"===document.readyState?n():window.addEventListener("load",n,{once:!0}))})()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:200},mobile:{show:!1},react:{opacity:.7}})</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})})</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o=d[n],i=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)};(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,a=t.getAttribute("data-original"),e.onload=function(){t.src=a,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),i()},e.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=a},t.src!==a&&(e.src=a)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this)</script></body></html>